{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"nix-core docs","text":"<p>Welcome to the documentation for nix-core.</p> <p>The goal of this project is to provide modules and packages for your NixOS and Home Manager configurations, suitable for client and server applications. Scripts are also included to automate the creation and installation of your own flake.</p>"},{"location":"#explore-the-documentation","title":"Explore the documentation:","text":"<ul> <li>Introduction to Nix: Understand the fundamentals of the Nix language and package manager, as well as NixOS. Start here if you are new.</li> <li>Getting Started: A guide to go from scratch to a complete, working NixOS configuration using nix-core. Start here if you know about Nix and NixOS.</li> <li>Modules: Information about available NixOS and Home Manager modules.</li> <li>Tips: Find recommendations and resources to navigate the Nix ecosystem.</li> </ul>"},{"location":"getting-started/add-configs/","title":"Add NixOS and Home Manager configurations","text":"<p>Choose a configuration template from this list.</p> <p>Run the <code>create</code> script to add your desired configuration template to your nix-config flake:</p> <pre><code>nix --experimental-features \"nix-command flakes\" run github:sid115/nix-core#apps.x86_64-linux.create -- \\\n-t TEMPLATE \\\n-u USERNAME \\\n-H HOST \\\n--git-name GIT_NAME \\\n--git-email GIT_EMAIL \\\n-f ~/.config/nixos\n</code></pre> <p>Change the architecture if needed. Supported architectures are listet under <code>supportedSystems</code> inside <code>flake.nix</code>.</p> <p>See the script's help page for reference:</p> <pre><code>Usage: create -t|--template TEMPLATE -u|--user USERNAME -H|--host HOSTNAME [-f|--flake PATH/TO/YOUR/NIX-CONFIG] [--git-name GIT_NAME] [--git-email GIT_EMAIL]\n\nOptions:\n    -t, --template TEMPLATE    Configuration template to use (mandatory)\n    -u, --user USERNAME        Specify the username (mandatory)\n    -H, --host HOSTNAME        Specify the hostname (mandatory)\n    -f, --flake FLAKE          Path to your flake directory (optional, default: ~/.config/nixos)\n    --git-name GIT_NAME        Specify the git name (optional, default: USERNAME)\n    --git-email GIT_EMAIL      Specify the git email (optional, default: USERNAME@HOSTNAME)\n    -h, --help                 Show this help message\n\nAvailable configuration templates:\n    hyprland\n    server\n    pi4\n    vm-uefi\n</code></pre> <p>All templates should work right out of the box. You only need to edit the disk partitioning script (<code>disks.sh</code>) or provide a disko configuration (<code>disko.nix</code>) in your host directory. A basic single disk partitioning script is provided. Set your disk by its ID, which comes from <code>ls -lAh /dev/disk/by-id</code>.</p> <p>Warning: The create script applies patch files. It will print what it patched to stdout. It is strongly recommended to verify them manually.</p> <p>If you like, you can lock your flake before committing by running:</p> <pre><code>nix --experimental-features \"nix-command flakes\" flake lock\n</code></pre>"},{"location":"getting-started/create-nix-config/","title":"Create your own nix-config flake","text":"<p>Create an empty directory and apply the nix-config template to it:</p> <pre><code>mkdir -p ~/.config/nixos\ncd ~/.config/nixos\nnix flake init -t \"github:sid115/nix-core#templates.nix-config\"\n</code></pre> <p>Note: You do not have to use <code>~/.config/nixos</code>, but configuration related scripts in this repository will use this directory as the default nix-config flake directory.</p>"},{"location":"getting-started/install-instructions/","title":"Installation Guide","text":"<p>This guide will walk you through installing NixOS using the provided installation script <code>install.sh</code>.</p>"},{"location":"getting-started/install-instructions/#prerequisites","title":"Prerequisites","text":"<ol> <li>Bootable NixOS Installation Medium: Make sure you have booted into NixOS live environment from the Minimal ISO image. Read the official NixOS installation guide for more information on how to create a bootable NixOS USB drive.</li> <li>Network Connection: Ensure the target machine is connected to the internet.</li> <li>Host configuration: The target machine needs to have a working NixOS configuration inside your own flake. A hardware configuration is not required as it can be generated automatically during installation.</li> <li>Disks setup: The target machine needs to have a working disk configuration or partitioning script inside <code>hosts/HOSTNAME</code>. Disko expects its configuration to be in <code>hosts/HOSTNAME/disks.nix</code>. Alternatively, a shell script can be provided at <code>hosts/HOSTNAME/disks.sh</code> that will format, partition, and mount disks.</li> </ol> <p>Using UEFI is recommended.</p>"},{"location":"getting-started/install-instructions/#optional-virt-manager-config-for-wayland","title":"Optional: Virt-Manager config for Wayland","text":"<p>If you want to install NixOS with Wayland support inside a VM using Virt-Manager, enable 3D acceleration by checking <code>Customize configuration before install</code>:</p> <ol> <li>Go to <code>Display &lt;VNC or Spice&gt;</code> and select <code>Spice Server</code> under <code>Type</code>. Select <code>None</code> under <code>Listen type</code>. Check <code>OpenGL</code> and select a device that is not from Nvidia.</li> <li>Go to <code>Video &lt;some name&gt;</code> and select <code>Virtio</code> under <code>Model</code>. Check <code>3D acceleration</code>.</li> <li>Click <code>Begin installation</code> in the top left corner.</li> </ol> <p>If you get the error:</p> <pre><code>Unable to complete install: 'unsupported configuration: domain configuration does not support video model 'virtio''\n</code></pre> <p>Install the package <code>qemu-full</code>:</p> <pre><code>sudo pacman -Syy qemu-full\n</code></pre> <p>assuming you are on Arch Linux</p> <p>Then, reboot.</p>"},{"location":"getting-started/install-instructions/#steps","title":"Steps","text":"<p>Boot into NixOS ISO image on your target machine.</p>"},{"location":"getting-started/install-instructions/#0-ssh-into-the-target-machine","title":"0. SSH into the Target Machine","text":"<p>If you are using a remote machine, set a password for the user nixos using <code>passwd</code>. Then, SSH into it using the following command:</p> <pre><code>ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no nixos@&lt;host-ip-address&gt;\n</code></pre> <p>Replace <code>&lt;host-ip-address&gt;</code> with the IP address of the target machine which can be found using <code>ip a</code>.</p>"},{"location":"getting-started/install-instructions/#1-become-root","title":"1. Become root","text":"<p>The default user <code>nixos</code> has sudo privileges. Become root to run the install script:</p> <pre><code>sudo -i\n</code></pre>"},{"location":"getting-started/install-instructions/#2-run-the-install-script","title":"2. Run the Install Script","text":"<p>Download the install script to the target machine and run it:</p> <pre><code>nix --experimental-features \"nix-command flakes\" run github:sid115/nix-core#apps.x86_64-linux.install -- \\\n-n HOST \\\n-r REPOSITORY\n</code></pre> <p>Replace <code>HOST</code> with the name of your target machine.  Replace <code>REPOSITORY</code> with your flake URL.  You can specify a branch with <code>-b BRANCH</code> (default: <code>master</code>)  Print the usage page with <code>-h</code>.  Change the architecture if needed.</p>"},{"location":"getting-started/install-instructions/#3-reboot-your-system","title":"3. Reboot your System","text":"<p>Once the installation completes, unmount the installation medium:</p> <pre><code>umount -Rl /mnt\n</code></pre> <p>If you have your root file system on ZFS, export all pools: <code>zpool export -a</code></p> <p>Then, you can safely remove the installation medium and reboot your machine:</p> <p>If you generated a new hardware configuration, you should save it before rebooting:  <code>cat /tmp/nixos/hosts/HOSTNAME/hardware.nix</code></p> <pre><code>reboot now\n</code></pre>"},{"location":"getting-started/install-instructions/#4-login","title":"4. Login","text":"<p>Upon reboot, your system will boot into the newly installed NixOS. Login as a valid user defined in the configuration of the host (<code>hosts/HOSTNAME/default.nix</code>). The default initial password is <code>changeme</code>. Change your password with <code>passwd</code> after login.</p>"},{"location":"getting-started/install-instructions/#5-optional-import-age-keys","title":"5. Optional: Import age keys","text":"<p>If you use sops-nix with age in you Home Manager configuration, you need to import your age keys:</p> <pre><code>mkdir -p ~/.config/sops/age\ncp /PATH/TO/YOUR/keys.txt ~/.config/sops/age/keys.txt\n</code></pre>"},{"location":"getting-started/install-instructions/#6-clone-your-repository","title":"6. Clone your Repository","text":"<p>Git is installed on every system by default. Clone your flake repository to your home directory:</p> <pre><code>git clone YOUR_GIT_REPO_URL ~/.config/nixos\n</code></pre> <p>The rebuild script expects your flake to be in <code>~/.config/nixos</code></p>"},{"location":"getting-started/install-instructions/#7-apply-your-home-manager-configuration","title":"7. Apply your Home Manager Configuration","text":"<p>Home Manager is not installed by default. Enter the development shell to apply the configuration:</p> <pre><code>nix-shell ~/.config/nixos/shell.nix --run 'rebuild home'\n</code></pre>"},{"location":"getting-started/install-instructions/#8-reboot-your-system","title":"8. Reboot your System","text":"<p>Once the home-manager configuration is applied, reboot your system:</p> <pre><code>sudo reboot now\n</code></pre> <p>You may now log in. Your system is now fully configured.</p>"},{"location":"introduction-to-nix/derivations/","title":"Derivations","text":"<p>At its core, Nix is about building software. Nix doesn't install software directly from a global repository; instead, it builds derivations. A derivation is a description of how to build a package. It's a pure function <code>inputs -&gt; output</code>, meaning given the same inputs, it will always produce the same output.</p>"},{"location":"introduction-to-nix/derivations/#your-first-derivation","title":"Your first Derivation","text":"<p>Let's build a simple \"hello world\" program.</p> <p>First, create a C source file <code>hello.c</code>:</p> <pre><code>// hello.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello from C!\\n\");\n    return 0;\n}\n</code></pre> <p>Then, create a <code>default.nix</code> file that imports Nixpkgs and then calls the package definition below.</p> <pre><code># default.nix\n{ pkgs ? import &lt;nixpkgs&gt; {} }: # Fetch Nixpkgs\n# Nixpkgs is a collection of Nix expressions.\n# We need some functions (like `callPackage`) that are defined there.\n# Nixpkgs will be covered later in this guide.\n\npkgs.callPackage ./my-hello.nix { }\n# `callPackage` is a helper function for Package derivations.\n# It automatically resolves all needed input arguments the derivation needs from Nixpkgs.\n</code></pre> <p>Hint: <code>default.nix</code> will get replaced by Nix Flakes later. You do not need to know what Flakes are at the moment, but keep this relationship in mind.</p> <p>Now, define how to build the C source file a Nix file, <code>my-hello</code>.nix:</p> <pre><code># my-hello.nix\n{ stdenv }: # Inputs\n\nstdenv.mkDerivation {\n  pname = \"my-hello\"; # Package name\n  version = \"0.1.0\";  # Package version\n\n  src = ./.; # The source code for the package is in the current directory\n\n  # Phases of the build process\n  # mkDerivation defines standard phases like unpackPhase, patchPhase, configurePhase, buildPhase, installPhase\n  # For simple builds, we just need build and install.\n\n  buildPhase = ''\n    # Compile command\n    ${stdenv.cc}/bin/gcc hello.c -o hello\n  '';\n\n  installPhase = ''\n    # Install the compiled program into the output directory ($out)\n    mkdir -p $out/bin\n    cp hello $out/bin/hello\n  '';\n}\n</code></pre> <p>Let's break this down:</p> <ul> <li><code>stdenv</code>: This derivation is a function that expects <code>stdenv</code> (standard environment, providing common build tools and phases) as an argument. It will be automatically resolved from Nixpkgs.</li> <li><code>stdenv.mkDerivation</code>: This is the core function to create a derivation. It sets up a standard build environment and provides a set of common build phases.</li> <li><code>pname</code>, <code>version</code>: Standard metadata for the package.</li> <li><code>src = ./.;</code>: This tells Nix to copy all files from the current directory into the build sandbox.</li> <li><code>buildPhase</code>: This is where you put commands to compile your software. Here, <code>gcc</code> is used from the standard C compiler provided by <code>stdenv.cc</code> to compile <code>hello.c</code> into an executable <code>hello</code>.</li> <li><code>installPhase</code>: This is where you put commands to install the build artifacts into the <code>$out</code> directory, which is the final location in the Nix store. Here, a <code>bin</code> directory is created to move the <code>hello</code> executable into.</li> </ul>"},{"location":"introduction-to-nix/derivations/#building-and-running-a-derivation","title":"Building and Running a Derivation","text":"<p>To build this derivation, use <code>nix build</code>:</p> <pre><code>nix build --file default.nix\n</code></pre> <p>You'll see output from the build process. If successful, Nix creates a <code>result</code> symlink in your current directory. This <code>result</code> symlink points to the package in the Nix store.</p> <p>Now, run your compiled program:</p> <p><pre><code>./result/bin/hello\n</code></pre> <pre><code>Hello from C!\n</code></pre></p>"},{"location":"introduction-to-nix/flakes/","title":"Flakes","text":"<p>Flakes are still an experimental feature in Nix. However, they are so widely used by the community that they almost became standard. Furthermore, nix-core uses Flakes.</p> <p>Nix flakes are a reproducible way to define, build, and deploy Nix projects, making them reliable and portable.</p> <p>Flakes accomplish that by:</p>"},{"location":"introduction-to-nix/flakes/#standardized-input","title":"Standardized Input","text":"<p>They define a fixed, declarative input (the <code>flake.nix</code> file) that specifies all project dependencies, sources, and outputs. This eliminates implicit dependencies or environment variables that could cause builds to differ.</p> <p>Example in <code>flake.nix</code>:</p> <pre><code>inputs = {\n  nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\"; # Declare we need nixpkgs, specifically this branch\n};\n</code></pre>"},{"location":"introduction-to-nix/flakes/#reproducible-lock-file","title":"Reproducible \"Lock File\"","text":"<p>When you build or develop with a flake, Nix generates a <code>flake.lock</code> file. This file records the exact content-addressable hashes of all transitive inputs used for that specific build. This lock file can be committed to version control, ensuring that anyone else cloning the repository (or a CI system) will use precisely the same set of inputs and thus achieve the identical result.</p> <p>Example <code>flake.lock</code> entry for <code>nixpkgs</code>:</p> <pre><code>\"nixpkgs\": {\n  \"locked\": {\n    \"lastModified\": 1709259160,\n    \"narHash\": \"sha256-...\",\n    \"owner\": \"NixOS\",\n    \"repo\": \"nixpkgs\",\n    \"rev\": \"b2f67f0b5d1a8e1b3c9f2d1e0f0e0c0b0a090807\", // The exact commit!\n    \"type\": \"github\"\n  },\n  \"original\": {\n    \"owner\": \"NixOS\",\n    \"repo\": \"nixpkgs\",\n    \"type\": \"github\",\n    \"url\": \"github:NixOS/nixpkgs/nixos-23.11\"\n  }\n}\n</code></pre>"},{"location":"introduction-to-nix/flakes/#flake-schema","title":"Flake Schema","text":"<p>The <code>flake.nix</code> has a well-defined structure for <code>inputs</code> (sources like Git repos, other flakes) and <code>outputs</code> (packages, applications, modules, etc.). This consistent schema makes flakes composable and predictable.</p> <p>A <code>flake.nix</code> file typically looks like this:</p> <pre><code># flake.nix\n{\n  description = \"A simple example flake\";\n\n  inputs = {\n    # Inputs are other flakes or external resources\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\"; # Locked to a specific branch/version\n    # This is how you would add nix-core to your flake:\n    # core.url = \"github:sid115/nix-core\"\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: # 'self' refers to this flake, inputs are available\n    let\n      # Define common arguments for packages from nixpkgs\n      # This ensures all packages use the same version of Nixpkgs on this system\n      pkgs = import nixpkgs {\n        system = \"x86_64-linux\"; # The target system architecture\n      };\n    in\n    {\n      # Outputs include packages, devShells, modules, etc.\n      # Packages that can be built by `nix build .#&lt;package-name&gt;`\n      packages.x86_64-linux.my-app = pkgs.callPackage ./pkgs/my-app { };\n      packages.x86_64-linux.my-other-app = pkgs.hello; # From nixpkgs directly\n\n      # Development shells that can be entered using `nix develop`\n      devShells.x86_64-linux.default = pkgs.mkShell {\n        name = \"my-dev-env\";\n        buildInputs = [ pkgs.nodejs pkgs.python3 ];\n        shellHook = \"echo 'Welcome to my dev environment!'\";\n      };\n\n      # NixOS modules (for system config)\n      # nixosConfigurations.&lt;hostname&gt;.modules = [ ./nixos-modules/webserver.nix ];\n      # (This is more advanced and will be covered in NixOS section)\n    };\n}\n</code></pre> <p>Key parts of a <code>flake.nix</code>:</p> <ul> <li><code>description</code>: A human-readable description of your flake.</li> <li><code>inputs</code>: Defines all dependencies of your flake. Each input has a <code>url</code> pointing to another flake (e.g., a GitHub repository, a local path, or a Git URL) and an optional <code>follows</code> attribute to link inputs.</li> <li><code>outputs</code>: A function that takes <code>self</code> (this flake) and all <code>inputs</code> as arguments. It returns an attribute set defining what this flake provides. Common outputs are <code>packages</code>, <code>devShells</code>, <code>nixosConfigurations</code>, etc., usually segregated by system architecture. You can read more about flake outputs in the NixOS &amp; Flakes Book.</li> </ul>"},{"location":"introduction-to-nix/flakes/#nix-flake-commands","title":"<code>nix flake</code> Commands","text":"<p>The <code>nix flake</code> subcommand is your primary interface for interacting with flakes. Let's create a new flake to demonstrate them:</p> <p>Initialize the flake:</p> <pre><code>mkdir my-flake &amp;&amp; cd my-flake\nnix flake init\n</code></pre> <p>This creates a minimal <code>flake.nix</code>.</p> <p>Lock your flake:</p> <pre><code>nix flake lock\n</code></pre> <p>This creates <code>flake.lock</code>, a file that locks the exact versions of your inputs.</p> <p>Update flake inputs:</p> <pre><code>nix flake update\n</code></pre> <p>This updates all inputs to their latest versions allowed by their <code>url</code> (e.g., the latest commit on <code>nixos-unstable</code> for <code>nixpkgs</code>) and then updates the <code>flake.lock</code> file. Since we just locked the flake for the first time, there probably won't be any updates available.</p> <p>Print flake inputs:</p> <pre><code>nix flake metadata\n</code></pre> <p>Print flake outputs:</p> <pre><code>nix flake show\n</code></pre> <p>Build packages from a flake:</p> <pre><code>nix build .#hello # The '.' refers to the current directory's flake\n./result/bin/hello\n</code></pre> <p>Run a package from a flake:</p> <pre><code>nix run .#hello\n</code></pre> <p>Since the <code>packages.&lt;system&gt;.default</code> output exists, you can just do <code>nix run</code>.</p>"},{"location":"introduction-to-nix/flakes/#nix-develop","title":"<code>nix develop</code>","text":"<p>This command spins up a temporary shell environment with all the tools and dependencies specified in your flake's <code>devShells</code> output.</p> <p>Let's expand your <code>flake.nix</code>:</p> <pre><code># flake.nix\n{\n  description = \"A very basic flake\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs?ref=nixos-unstable\";\n  };\n\n  outputs =\n    { self, nixpkgs }:\n    let\n      # Define `pkgs` for the current system\n      pkgs = import nixpkgs {\n        system = \"x86_64-linux\";\n      };\n    in\n    {\n      packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n      # With `pkgs` defined, we could also do this:\n      # packages.x86_64-linux.hello = pkgs.hello;\n\n      packages.x86_64-linux.default = self.packages.x86_64-linux.hello;\n\n      devShells.x86_64-linux.default = pkgs.mkShell {\n        # Packages available in the shell\n        packages = [\n          pkgs.git\n          pkgs.go\n          pkgs.neovim\n        ];\n        # Environment variables for the shell\n        GIT_COMMITTER_EMAIL = \"your-email@example.com\";\n        # Commands to run when entering the shell\n        shellHook = ''\n          echo \"Entering development shell for my project.\"\n          echo \"You have Git, Go, and Neovim available.\"\n        '';\n      };\n    };\n}\n</code></pre> <p>Now, from your project directory:</p> <pre><code>nix develop\n</code></pre> <p>You'll instantly find yourself in a shell where <code>git</code>, <code>go</code>, and <code>nvim</code> are available, and your <code>GIT_COMMITTER_EMAIL</code> is set. When you exit, your regular shell environment is restored \u2013 no lingering installations or modified global state. This makes it incredibly easy to switch between projects, each with its specific toolchain and dependencies, without conflicts.</p>"},{"location":"introduction-to-nix/install-nix/","title":"Install Nix","text":"<p>Install the Nix package manager according to the official documentation on nixos.org.</p> <p>On Linux, simply run:</p> <pre><code>sh &lt;(curl --proto '=https' --tlsv1.2 -L https://nixos.org/nix/install) --daemon\n</code></pre>"},{"location":"introduction-to-nix/install-nix/#configuration","title":"Configuration","text":"<p>Add the following to <code>~/.config/nix/nix.conf</code> (recommended) or <code>/etc/nix/nix.conf</code>:</p> <pre><code>experimental-features = nix-command flakes\n</code></pre> <ul> <li><code>nix-command</code> enables the new <code>nix</code> CLI Nix is transitioning to.</li> <li><code>flakes</code> will be covered later in this guide. Don't worry about them for now.</li> </ul> <p>Reload your session to get access to the <code>nix</code> command.</p>"},{"location":"introduction-to-nix/nix-speedrun/","title":"Nix Speedrun","text":"<p>This section will cover some Nix language basics as fast as possible.</p>"},{"location":"introduction-to-nix/nix-speedrun/#comments","title":"Comments","text":"<pre><code># This is a comment\n\n/*\n  This is a block comment\n*/\n</code></pre>"},{"location":"introduction-to-nix/nix-speedrun/#data-types","title":"Data types","text":"<p>Every value in Nix has a type. Some basic types are:</p> <pre><code>16 # integer\n\n3.14 # float\n\nfalse # boolean\n\n\"Hello, world!\" # string\n\n''\n  This is also a string,\n  but over multiple lines!\n''\n</code></pre> <p>Assign a value to a variable:</p> <pre><code>myVar = \"99\";\n</code></pre> <p>And then inject it into a string:</p> <pre><code>''\n  I got ${myVar} problems,\n  but Nix ain't one.\n''\n</code></pre> <p>Nix also has compound values. This is a list:</p> <pre><code>[ 123 \"hello\" true null [ 1 2 ] ]\n</code></pre> <p>You can mix different types in a list. This is an attribute set:</p> <pre><code>{\n  foo = 4.56;\n  bar = {\n    baz = \"this\";\n    qux = false;\n  };\n}\n</code></pre> <p>An attribute set is like an object. It is a collection of name-value-pairs called attributes. The expression above is equivalent to:</p> <pre><code>{\n  foo = 4.56;\n  bar.baz = \"this\";\n  bar.qux = false;\n}\n</code></pre>"},{"location":"introduction-to-nix/nix-speedrun/#evaluation","title":"Evaluation","text":"<p>In Nix, everything is an expression that evaluates to a value. Create a <code>hello.nix</code>-file with the following content:</p> <pre><code>\"Hello, world!\"\n</code></pre> <p>Then, evaluate the file:</p> <pre><code>nix eval --file hello.nix\n</code></pre> <pre><code>Hello, world!\n</code></pre> <p>A let-expression allows you to define local variables for an expression:</p> <pre><code>let\n  alice = {\n    name = \"Alice\";\n    age = \"26\";\n  };\nin\n''\n  Her name is ${alice.name}.\n  She is ${alice.age} years old.\n''\n</code></pre>"},{"location":"introduction-to-nix/nix-speedrun/#functions","title":"Functions","text":"<p>Functions have the following form:</p> <pre><code>pattern: body\n</code></pre> <p>The pattern specifies what the argument of the function must look like, and binds variables in the body to (parts of) the argument.</p> <pre><code>let\n  increment = num: num + 1;\nin\nincrement 49\n</code></pre> <p>Functions can only have a single argument. For multiple arguments, nest functions:</p> <pre><code>let\n  isAllowedToDrive =\n    name: age:\n    if age &gt;= 18 then \"${name} is eligible to drive.\" else \"${name} is too young to drive yet.\";\nin\nisAllowedToDrive \"Charlie\" 19\n</code></pre> <p>It is common to pass multiple arguments in an attribute set instead. Since Nix is lazily evaluated, you can define multiple bindings in the same let-statement.</p> <pre><code>let\n  add = { a, b }: a + b;\n  result = add { a = 34; b = 35; };\nin\nresult\n</code></pre> <p>You can also set optional arguments by providing default values:</p> <pre><code>let\n  greet = { greeting ? \"Hello\", name }: \"${greeting}, ${name}!\";\nin\ngreet { name = \"Bob\"; }\n</code></pre> <p>Let's look at one last example:</p> <pre><code>let\n  myFunc = { a, b, c }: a + b * c;\n\n  numbers = {\n    a = 1;\n    b = 2;\n    c = 3;\n  };\n\n  result = myFunc { a = numbers.a; b = numbers.b; c = numbers.c; };\nin\nresult\n</code></pre> <p>Nix provides some syntactical sugar to simplify that function call. The <code>with</code> keyword brings all attributes from an attribute set into the scope:</p> <pre><code># ...\n  result = with numbers; myFunc { a = a; b = b; c = c; };\n# ...\n</code></pre> <p>However, this syntax is discouraged. Use <code>inherit</code> instead to explicitly list attributes to bring into the scope:</p> <pre><code># ...\n  inherit (numbers) a b c;\n  result = myFunc { inherit a b c; };\n# ...\n</code></pre>"},{"location":"introduction-to-nix/nix-speedrun/#builtin-functions","title":"Builtin functions","text":"<p>Nix provides builtin functions by default through the global <code>builtins</code> constant. For example, <code>builtins.attrNames</code> gives you a list of all attributes of the given attribute set:</p> <pre><code>builtins.attrNames { a = 1; b = 2; }\n# =&gt; [ \"a\" \"b\" ]\n</code></pre> <p>Yes, this means that attribute keys, though defined as variables, are available as strings.</p> <p>Some builtins are so common that the <code>builtins</code> prefix can be omitted. <code>map</code> is a builtin function that applies a function to each element of a list.</p> <pre><code># squares.nix\nlet\n  numbers = [ 5 2 1 4 3 ];\n  squares = map (n: n * n) numbers;\nin\n{\n  inherit numbers squares;\n}\n</code></pre> <p>The <code>import</code> function allows to separate the codebase into multiple files:</p> <pre><code># sort.nix\nlet\n  results = import ./squares.nix; # paths have their own type\n  inherit (results) squares;\n  inherit (builtins) sort lessThan;\nin\nsort lessThan squares\n</code></pre> <p>The <code>sort</code> function can be found in the Nix manual.</p>"},{"location":"introduction-to-nix/nix-store/","title":"Nix Store","text":"<p>You've built a package, and it landed in the <code>/nix/store</code>. The Nix store is the heart of Nix's reproducibility, atomicity, and rollback capabilities.</p>"},{"location":"introduction-to-nix/nix-store/#unique-paths-hashing","title":"Unique Paths (Hashing)","text":"<p>Every piece of software, configuration, or data managed by Nix lives in the Nix store under a unique, cryptographically hashed path. For example, <code>nix build</code> might produce something like:</p> <pre><code>/nix/store/zx9qxw749wmla1fad93al7yw2mg1jvzf-my-hello-0.1.0\n</code></pre> <p>A Nix store path consists of its hash and a human readable name with a version, which are defined in the corresponding derivation. The hash ensures:</p> <ol> <li>Immutability: Entries in the Nix Store are read only. Once something is in the Nix store, it never changes. If you modify a source file or a build instruction, it creates a new derivation with a new hash, and thus a new path in the store. The old version remains untouched.</li> <li>Reproducibility: If two different systems build the exact same derivation, they will produce the exact same hash and thus the exact same path. This guarantees that \"it works on my machine\" translates to \"it works on any Nix machine.\"</li> <li>Collision Avoidance: Because the path includes a hash of all its inputs (source code, build script, compiler, libraries, etc.), different versions or configurations of the same package can coexist peacefully in the store without conflicting.</li> </ol> <p>You can inspect the contents of a store path directly:</p> <pre><code>ls -l /nix/store/zx9qxw749wmla1fad93al7yw2mg1jvzf-my-hello-0.1.0/bin\n</code></pre> <p>Replace the hash with the actual hash from your previous <code>nix build</code> command or <code>ls -l result</code>.</p>"},{"location":"introduction-to-nix/nix-store/#dependency-resolution","title":"Dependency Resolution","text":"<p>The Nix store is also a giant, explicit dependency graph. When you define a derivation for <code>my-hello</code> that uses <code>stdenv</code> and <code>gcc</code>, Nix doesn't just build <code>my-hello</code>. It first ensures that <code>stdenv</code> and <code>gcc</code> (and their own dependencies, recursively) are also present in the Nix store.</p> <p>Let's look at the dependencies of your <code>my-hello</code> derivation:</p> <pre><code>nix path-info --recursive ./result\n</code></pre> <p>This command will list all the Nix store paths that <code>my-hello</code> directly or indirectly depends on. You'll see things like <code>glibc</code>, <code>gcc</code>, and many other low-level system libraries. Each of these is itself a derivation built and stored in the Nix store under its own unique hash.</p> <p>This means that conflicts are impossible because different versions of the same library (e.g., <code>libssl-1.0</code> and <code>libssl-3.0</code>) can coexist peacefully in <code>/nix/store</code> under their distinct hashes.</p>"},{"location":"introduction-to-nix/nixos/","title":"NixOS","text":"<p>NixOS is a Linux distribution built entirely on top of the Nix package manager and the Nix language. This means your entire operating system, from the kernel to user-space applications and system services, is declared in a set of Nix expressions. This brings all the benefits of Nix (reproducibility, atomic upgrades, easy rollbacks) to your whole system.</p>"},{"location":"introduction-to-nix/nixos/#nixos-configuration-with-flakes","title":"NixOS Configuration (with Flakes)","text":"<p>With flakes, your NixOS configuration typically resides in a <code>flake.nix</code> file that exports a <code>nixosConfigurations</code> output.</p> <p>Let's have a look at a basic <code>flake.nix</code> for a NixOS machine.</p> <pre><code># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs =\n    {\n      self, # The flake itself\n      nixpkgs, # The nixpkgs input\n      ...\n    }@inputs: # `self` and `nixpkgs` are available under `inputs`\n    let\n      inherit (self) outputs;\n    in\n    {\n      # Define NixOS configurations\n      nixosConfigurations = {\n        # Name for this specific system configuration\n        your-pc = nixpkgs.lib.nixosSystem {\n          # Arguments passed to all NixOS modules\n          specialArgs = {\n            inherit inputs outputs;\n          };\n          # List of all configuration files (modules)\n          modules = [ ./configuration.nix ];\n        };\n      };\n    };\n}\n</code></pre> <p>The <code>nixosSystem</code> function takes a list of <code>modules</code>. Each module is a Nix expression that defines desired system state and settings. So the actual system configuration lives in <code>configuration.nix</code>:</p> <pre><code># configuration.nix\n{ config, pkgs, ... }: # The arguments provided to a NixOS module\n\n{\n  # Enable a display manager and desktop environment\n  services.displayManager.lightdm.enable = true;\n  services.desktopManager.gnome.enable = true; # Or kde, xfce, etc.\n\n  # List of packages to be installed globally\n  environment.systemPackages = with pkgs; [\n    firefox\n    neovim\n    git\n  ];\n\n  # Configure networking\n  networking.hostName = \"my-nixos-desktop\";\n\n  # Users\n  users.users.Alice = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ]; # Add user to groups for sudo and network management\n    initialPassword = \"changeme\"; # Set a temporary password\n  };\n\n  # Set system-wide locale\n  i18n.defaultLocale = \"en_US.UTF-8\";\n\n  # Set the system time zone\n  time.timeZone = \"America/New_York\";\n\n  # ... many more options ...\n}\n</code></pre> <p>Please note that the above configuration is not a complete working NixOS configuration. It just showcases how to you can define your system declaratively.</p> <p>The <code>config</code> argument is the evaluated final configuration of your system. You use it to refer to other parts of your configuration. For example, you might make one service depend on another's path: </p> <pre><code>myService.dataPath = config.services.otherService.dataPath;\n</code></pre> <p>It's primarily used for referencing options within the configuration.</p>"},{"location":"introduction-to-nix/nixos/#the-module-system","title":"The Module System","text":"<p>NixOS uses a powerful module system. A module is a Nix expression that declares:</p> <ul> <li><code>options</code>: What configurable parameters this module exposes.</li> <li><code>config</code>: How this module sets those parameters (and potentially other system parameters).</li> <li><code>imports</code>: Other modules to include.</li> </ul> <p>When you build your NixOS configuration using <code>nixos-rebuild switch --flake path/to/flake/directory#your-pc</code>, NixOS collects all the options and configurations from all activated modules, merges them, and then builds a new system closure in the Nix store.</p>"},{"location":"introduction-to-nix/nixos/#searching-nixos-options","title":"Searching NixOS Options","text":"<p>There are thousands of options in NixOS. You can search them in the NixOS Options Search.</p> <p>For example, search for <code>services.desktopManager</code> to list all options regarding desktop managers.</p>"},{"location":"introduction-to-nix/nixos/#home-manager","title":"Home Manager","text":"<p>While NixOS manages system-wide configurations, Home Manager applies the power of Nix to your user-specific configuration files and dotfiles. Instead of manually symlinking dotfiles or writing install scripts, you define your user environment declaratively in Nix. Home Manager applies Nix's declarative power to the user space, much like NixOS does for the system space.</p> <p>Let's extend our <code>flake.nix</code>:</p> <pre><code># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      home-manager,\n      ...\n    }@inputs:\n    let\n      inherit (self) outputs;\n    in\n    {\n      nixosConfigurations = {\n        your-pc = nixpkgs.lib.nixosSystem {\n          specialArgs = {\n            inherit inputs outputs;\n          };\n          modules = [ ./configuration.nix ];\n        };\n      };\n\n      homeConfigurations = {\n        your-user = home-manager.lib.homeManagerConfiguration {\n          pkgs = nixpkgs.legacyPackages.x86_64-linux;\n          extraSpecialArgs = {\n            inherit inputs outputs;\n          };\n          modules = [ ./home.nix ];\n        };\n      };\n    };\n}\n</code></pre> <p><code>home.nix</code> might look like this:</p> <pre><code># home.nix\n{ config, pkgs, ... }:\n\n{\n  # Define your user's home directory\n  home.username = \"youruser\";\n  home.homeDirectory = \"/home/youruser\";\n\n  # Install user-specific packages\n  home.packages = with pkgs; [\n    htop\n    cowsay\n  ];\n\n  # Configure zsh\n  programs.zsh.enable = true;\n  programs.zsh.ohMyZsh.enable = true;\n  programs.zsh.ohMyZsh.plugins = [ \"git\" \"history\" ];\n\n  # Git configuration\n  programs.git = {\n    enable = true;\n    userName = \"Your Name\";\n    userEmail = \"your.email@example.com\";\n  };\n\n  # ... many more options for things like VS Code, Tmux, themes, fonts etc.\n}\n</code></pre> <p>You could now build your Home Manager configuration with <code>home-manager switch --flake path/to/flake/directory#your-user</code>.</p> <p>Search for Home Manager options in the Home Manager Options Search.</p>"},{"location":"introduction-to-nix/nixos/#what-nix-core-does","title":"What nix-core does","text":"<p>The <code>nix-core</code> repository attempts to automate your NixOS and Home Manager experience. It exposes NixOS and Home Manager modules that sit on top of the already existing modules in NixOS and Home Manager respectively. Module options are added and opinionated defaults are set to get your configuration running with less configuration options needed to be set.</p> <p>Create your NixOS and Home Manager configuration flake (we call that <code>nix-config</code>) with nix-core as an input using a template provided in the repository. Adding NixOS and Home Manager configurations is automated through a shell script. You can choose between some configuration templates for server or client systems. The installation process is automated through a shell script as well. Also, an installation guide is provided. Rebuilding your NixOS and Home Manager configurations is wrapped in nix-core's rebuild script.</p> <p>The Getting Started Guide will take you from nothing to a working NixOS configuration using nix-core.</p>"},{"location":"introduction-to-nix/nixpkgs/","title":"Nixpkgs","text":"<p><code>Nixpkgs</code> is the massive collection of Nix expressions that define essentially all software available for Nix. It's the standard library for Nix, containing tens of thousands of packages. When you interact with <code>nixpkgs</code> in your Nix expressions, you're using this vast resource.</p>"},{"location":"introduction-to-nix/nixpkgs/#how-to-get-packages-from-nixpkgs","title":"How to Get Packages from Nixpkgs","text":"<p>The simplest way to use a package from Nixpkgs is to import it:</p> <pre><code>nix eval --impure --expr 'with import &lt;nixpkgs&gt; {}; pkgs.hello'\n</code></pre> <p>This evaluates an expression that imports Nixpkgs and makes its contents available as <code>pkgs</code>. The result will be a Nix store path for the <code>hello</code> package derivation.</p> <p>You can also use <code>nix build</code>:</p> <pre><code>nix build nixpkgs#hello\n</code></pre> <p>This will build and symlink <code>hello</code> into your current directory as <code>result</code>.</p> <p>And <code>nix run</code>:</p> <p><pre><code>nix run nixpkgs#hello/bin/hello\n</code></pre> <pre><code>Hello, world!\n</code></pre></p> <p>You could also run <code>./result/bin/hello</code>.</p> <p>This command tells Nix to run the <code>hello</code> executable from the <code>hello</code> package in Nixpkgs.</p>"},{"location":"introduction-to-nix/nixpkgs/#searching-nixpkgs","title":"Searching Nixpkgs","text":"<p>You can search for packages directly from your terminal:</p> <pre><code>nix search nixpkgs firefox\n</code></pre> <p>This command will list all packages in your Nixpkgs channel that contain \"firefox\" in their name or description. You'll likely see results like <code>firefox</code> and <code>firefox-bin</code>.</p> <p>However, the CLI is slow and not convenient to use. You should use the Nixpkgs search instead.</p> <p>This is the entry of Firefox in Nixpkgs:</p> <p></p>"},{"location":"introduction-to-nix/nixpkgs/#how-to-install-firefox","title":"How to install firefox?","text":"<p>You can use Nix as a traditional package manager:</p> <pre><code>nix-env -iA nixpkgs.firefox\n</code></pre> <p>This is not recommended as packages installed this way must be updated and maintained by the user in the same way as with a traditional package manager. To temporarily install a package for testing purposes, use <code>nix-shell</code> instead:</p> <pre><code>nix-shell -p firefox\n</code></pre> <p>This will spawn a shell with <code>firefox</code> available. To permanently install a package with Nix, add it to your NixOS or Home Manager configuration. NixOS and Home Manager will be covered later in this guide.</p>"},{"location":"introduction-to-nix/nixpkgs/#pkgslib-utility-functions","title":"<code>pkgs.lib</code> utility functions","text":"<p>The <code>pkgs</code> argument (or <code>nixpkgs</code> itself) isn't just a list of applications; it also provides a powerful utility library called <code>pkgs.lib</code>. This library contains helper functions for working with Nix expressions, strings, lists, and more.</p> <p>Many of these functions are used extensively within Nixpkgs itself to define packages and modules. You can browse the full <code>pkgs.lib</code> documentation online for more details.</p>"},{"location":"introduction-to-nix/nixpkgs/#the-nixpkgs-github-repository","title":"The Nixpkgs GitHub Repository","text":"<p>Nixpkgs is an open-source project hosted on GitHub: github.com/NixOS/nixpkgs. You can explore its source code to see how packages are defined. Every package definition is a Nix expression!</p> <p>For example, you could find the definition for <code>hello</code> at <code>pkgs/by-name/he/hello/package.nix</code>. It uses <code>stdenv.mkDerivation</code> just like our example.</p>"},{"location":"introduction-to-nix/nixpkgs/#binary-caches","title":"Binary Caches","text":"<p>Building everything from source every time can be slow. Nix solves this with binary caches. When someone builds a derivation, if that exact derivation (with its exact hash) has already been built and uploaded to a binary cache (like <code>cache.nixos.org</code>), Nix will simply download the pre-built binaries from the cache instead of building it locally.</p> <p>This is possible because of the unique hashing of store paths. If the hash matches, the content must be identical, so a downloaded binary is guaranteed to be the same as one built locally. This significantly speeds up package installation and system updates.</p>"},{"location":"introduction-to-nix/overview/","title":"Introduction to Nix","text":"<p>Welcome to the world of Nix! This guide aims to take you from a complete beginner to confidently using Nix for reproducible development environments and even managing your entire operating system with NixOS.</p> <p>Nix is a powerful package manager that brings functional programming principles to system configuration. This means your builds are reproducible, changes are atomic, and rollbacks are easy. Forget \"it works on my machine\" \u2013 with Nix, it works everywhere.</p> <p>We'll start with the fundamentals of the Nix language, then explore how Nix builds software. From there, we'll dive into the massive Nixpkgs collection, cover how Nix ensures reproducibility with flakes, and finally, show you how to manage your entire system with NixOS.</p> <p>Let's begin!</p>"},{"location":"modules/home/bemenu/","title":"bemenu","text":"<p><code>bemenu</code> is a dynamic menu library and client program inspired by dmenu.</p> <p>View the nix-core Home Manager module on GitHub. If you use this repository's Hyprland module, it is enabled by default.</p>"},{"location":"modules/home/bemenu/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/home/common/","title":"Common","text":"<p>The common module sets some opinionated defaults.</p> <p>View the nix-core Home Manager module on GitHub.</p> <p>It is recommended to import it in your Home Manager configuration as some nix-core modules may depend on it:</p> <pre><code>{ inputs, ... }:\n\n{\n  imports = [\n    inputs.core.homeModules.common\n  ];\n}\n</code></pre>"},{"location":"modules/home/gemini-cli/","title":"Gemini CLI","text":"<p>An open-source AI agent that brings the power of Gemini directly into your terminal.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/gemini-cli/#references","title":"References","text":"<ul> <li>GitHub</li> <li>CLI Docs</li> </ul>"},{"location":"modules/home/gemini-cli/#setup","title":"Setup","text":"<p>The package must be set by you. Easiest option is to use the nix-core overlay:</p> <pre><code>{ inputs, pkgs, ... }:\n\n{\n  imports = [\n    inputs.core.homeModules.gemini-cli\n  ];\n\n  programs.gemini-cli = {\n    enable = true;\n    package = pkgs.core.gemini-cli;\n  };\n}\n</code></pre> <p>Gemini CLI reads environment variables, such as your API key, from <code>~/.gemini/.env</code>. You can manage it with sops-nix:</p> <pre><code>{ config, ... }:\n\n{\n  sops.secrets.gemini-api-key = { };\n  sops.templates.gemini-cli-env = {\n    content = ''\n      GEMINI_API_KEY=${config.sops.placeholder.gemini-api-key}\n    '';\n    path = config.home.homeDirectory + \"/.gemini/.env\";\n  };\n}\n</code></pre> <p>Set <code>gemini-api-key</code> in your <code>secrets.yaml</code>:</p> <p>Replace <code>abc123</code> with your Gemini API key.</p> <pre><code>gemini-api-key: abc123\n</code></pre>"},{"location":"modules/home/gemini-cli/#troubleshooting","title":"Troubleshooting","text":"<p>These are some common warnings and errors you might encounter when using Gemini CLI:</p>"},{"location":"modules/home/gemini-cli/#error-saving-user-settings-file","title":"Error saving user settings file","text":"<pre><code>Error saving user settings file: Error: EROFS: read-only file system, open '/home/you/.gemini/settings.json'\n</code></pre> <p>This is intended behavior.</p>"},{"location":"modules/home/gpg/","title":"GPG","text":"<p>This module sets some defaults for gpg, mainly to let your gpg-agent handle ssh keys.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/gpg/#ssh-setup","title":"SSH Setup","text":""},{"location":"modules/home/gpg/#gpg_1","title":"GPG","text":"<p>You need a GPG authentication subkey. Follow the steps below to create one. If you already have a GPG key, skip to step 2.</p>"},{"location":"modules/home/gpg/#1-generate-a-new-gpg-key","title":"1. Generate a new GPG key","text":"<pre><code>gpg --full-gen-key --allow-freeform-uid\n</code></pre> <ol> <li>Select <code>1</code> as the type of key.</li> <li>Select <code>4096</code> for the keysize.</li> <li>Select <code>0</code> to choose 'Never expire'.</li> <li>Enter your name, email address, and a comment (if you want). Select <code>0</code> for 'Okay'.</li> </ol>"},{"location":"modules/home/gpg/#2-create-an-authentication-subkey","title":"2. Create an authentication subkey","text":"<pre><code>gpg --expert --edit-key KEY-ID\n</code></pre> <ol> <li>At the new <code>gpg&gt;</code> prompt, enter: <code>addkey</code></li> <li>When prompted, enter your passphrase.</li> <li>When asked for the type of key you want, select: (8) RSA (set your own capabilities).</li> <li>Enter <code>S</code> to toggle the \u2018Sign\u2019 action off.</li> <li>Enter <code>E</code> to toggle the \u2018Encrypt\u2019 action off.</li> <li>Enter <code>A</code> to toggle the \u2018Authenticate\u2019 action on. The output should now include Current allowed actions: Authenticate, with nothing else on that line.</li> <li>Enter <code>Q</code> to continue.</li> <li>When asked for a keysize, choose <code>4096</code>.</li> <li>Select <code>0</code> to choose 'Never expire'.</li> <li>Once the key is created, enter <code>quit</code> to leave the gpg prompt, and <code>y</code> at the prompt to save changes.</li> </ol>"},{"location":"modules/home/gpg/#hm-config","title":"HM config","text":"<pre><code>imports = [\n  inputs.core.homeModules.gpg\n];\n\nservices.gpg-agent.sshKeys = [ \"YOUR_AUTH_SUBKEY_KEYGRIP\" ];\n</code></pre> <p>Get the keygrip of your authentication subkey with: <code>gpg -K --with-keygrip</code></p>"},{"location":"modules/home/hyprland/","title":"Hyprland","text":"<p>This module extends the options of and sets some defaults for Hyprland:</p> <ul> <li>XDG Desktop Portal for screen sharing on Wayland</li> <li>XDG mime support and user directories</li> <li>enable Waybar as status bar</li> <li>enable dunst as notification service</li> <li>some packages</li> <li>keybindings</li> <li>manage default applications via the new <code>applications</code> option</li> </ul> <p>Always import both NixOS and Home Manager modules from <code>nix-core</code> when using Hyprland.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/hyprland/#keybindings","title":"Keybindings","text":"<p>The \"Master Layout\" is the only supported window layout.</p> <p><code>$mod</code>, <code>modifier</code> or <code>SUPER</code> refer to the same key which is the Windows key by default.</p> Keybinding Function <code>SUPER SHIFT c</code> Kill active window <code>SUPER 0..9</code> Focus workspace 1-10 (<code>0</code> maps to workspace 10) <code>SUPER SHIFT 0..9</code> Move active window to workspace 1-10 <code>SUPER CTRL 0..9</code> Focus workspace 1-10 on active monitor (moves if necessary) <code>SUPER Tab</code> Focus previous workspace on active monitor <code>SUPER SHIFT Tab</code> Move active window to previous workspace on active monitor <code>SUPER Comma</code> Focus left monitor <code>SUPER Period</code> Focus right monitor <code>SUPER SHIFT Comma</code> Move active workspace to left monitor <code>SUPER SHIFT Period</code> Move active workspace to right monitor <code>SUPER SHIFT Return</code> Make active window master <code>SUPER CTRL Return</code> Focus master window <code>SUPER j</code> Focus next window <code>SUPER k</code> Focus previous window <code>SUPER SHIFT j</code> Swap active window with the next window <code>SUPER SHIFT k</code> Swap active window with the previous window <code>SUPER h</code> Decrease horizontal space of master stack <code>SUPER l</code> Increase horizontal space of master stack <code>SUPER SHIFT h</code> Shrink active window vertically <code>SUPER SHIFT l</code> Expand active window vertically <code>SUPER i</code> Add active window to master stack <code>SUPER SHIFT i</code> Remove active window from master stack <code>SUPER o</code> Toggle between left and top orientation <code>SUPER Left</code> Focus window to the left <code>SUPER Right</code> Focus window to the right <code>SUPER Up</code> Focus upper window <code>SUPER Down</code> Focus lower window <code>SUPER SHIFT Left</code> Swap active window with window to the left <code>SUPER SHIFT Right</code> Swap active window with window to the right <code>SUPER SHIFT Up</code> Swap active window with upper window <code>SUPER SHIFT Down</code> Swap active window with lower window <code>SUPER f</code> Toggle floating for active window <code>SUPER CTRL f</code> Toggle floating for all windows on workspace <code>SUPER SHIFT f</code> Toggle fullscreen for active window <code>SUPER LMB</code> Move window by dragging <code>SUPER RMB</code> Resize window by dragging <p>Some media keys are also supported.</p>"},{"location":"modules/home/hyprland/#default-applications","title":"Default applications","text":"<p>For clarification purposes, let's define the following terms:</p> <ul> <li><code>&lt;application&gt;</code>: The literal name of the application/program. For example, <code>firefox</code>.</li> <li><code>&lt;category&gt;</code>: The category of the application. For example, <code>browser</code>.</li> <li><code>&lt;exec-field-code&gt;</code>: Available options are listed here. For example, <code>%U</code>.</li> </ul> <p>To add default applications to Hyprland, you need to do the following steps:</p>"},{"location":"modules/home/hyprland/#1-look-for-an-existing-category","title":"1. Look for an existing category","text":"<p>Check if a fitting category for your application exists in <code>applications/default.nix</code>. Categories are listed under <code>options.wayland.windowManager.hyprland.applications</code>, for example:</p> <pre><code># ...\nemailclient = mkAppAttrs {\n  default = \"thunderbird\";\n  bind = [ \"$mod, m, exec, ${emailclient}\" ];\n};\n\nfilemanager = mkAppAttrs {\n  default = \"lf\";\n  bind = [ \"$mod, e, exec, ${terminal} -T ${filemanager} -e ${filemanager}\" ];\n  windowRule = [\n    \"float, title:^${filemanager}$\"\n    \"size 50% 50%, title:^${filemanager}$\"\n  ];\n};\n# ...\n</code></pre> <p>If no fitting category exists, create a new one and assign a default application with optional binds and window rules.</p>"},{"location":"modules/home/hyprland/#2-create-a-directory-to-configure-the-application-in","title":"2. Create a directory to configure the application in","text":"<pre><code># applications/&lt;application&gt;/default.nix\n\n{ inputs, outputs, config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n  cfg = config.wayland.windowManager.hyprland;\n  app = cfg.applications.&lt;category&gt;;\nin\n{\n  imports = [\n    # Import a module if available.\n    outputs.homeModules.&lt;application&gt; # or `inputs.core.homeModules.&lt;application&gt;`\n  ];\n\n  config = mkIf (cfg.enable &amp;&amp; app == \"&lt;application&gt;\") {\n    programs.&lt;application&gt; = {\n      enable = true;\n      # Add more config here if needed.\n    };\n\n    # Define a desktop entry if the app's module or package does not ship with one\n    xdg.desktopEntries.&lt;application&gt; = {\n      name = \"&lt;application&gt;\"; # Use capital letters. For example, \"Firefox\".\n      genericName = \"&lt;category&gt;\"; # Be a bit more specific. For example, \"Web Browser\".\n      exec = \"&lt;application&gt; &lt;exec-field-code&gt;\"; # Program to execute, possibly with arguments.\n      terminal = false; #  Whether the program runs in a terminal window.\n      mimeType = [ \"&lt;mime1&gt;\" \"&lt;mime2&gt;\" ]; # The MIME type(s) supported by this application. For example, \"text/html\".\n    };\n  };\n}\n</code></pre> <p>The function <code>genMimeAssociations</code> might be useful here. See <code>feh</code>'s config as an example.</p> <p>Available MIME types can be found here.</p>"},{"location":"modules/home/hyprland/#3-import-the-directory","title":"3. Import the directory","text":"<p>You then need to import this directory in <code>applications/default.nix</code>. Look for the comment <code># add your application directories here</code>:</p> <pre><code># applications/default.nix\n\nimports = [\n  ./lf\n  ./thunderbird\n  # add your application directories here\n];\n</code></pre>"},{"location":"modules/home/kitty/","title":"Kitty","text":"<p><code>kitty</code> is a cross-platform, fast, feature-rich, GPU based terminal emulator.</p> <p>View the nix-core Home Manager module on GitHub. If you use this repository's Hyprland module, it is enabled by default.</p>"},{"location":"modules/home/kitty/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/home/lf/","title":"lf","text":"<p>Note: This module is not actively maintained. Expect things to break!</p> <p><code>lf</code> is a terminal file manager.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/lf/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/home/networkmanager-dmenu/","title":"networkmanager-dmenu","text":"<p>networkmanager-dmenu allows you to control NetworkManager via dmenu.</p> <p>View the nix-core Home Manager module on GitHub. If you use this repository's Hyprland module, it is enabled by default.</p>"},{"location":"modules/home/networkmanager-dmenu/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/home/nextcloud-sync/","title":"Nextcloud sync client","text":"<p>Because every other client sucks.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/nextcloud-sync/#setup","title":"Setup","text":"<p>This is an example home config:</p> <pre><code>{ inputs, config, ... }:\n\n{\n  imports = [\n    inputs.core.homeModules.nextcloud-sync\n  ];\n\n  services.nextcloud-sync = {\n    enable = true;\n    remote = \"cloud.portuus.de\"; # just the URL without `https://`\n    passwordFile = config.sops.secrets.nextcloud.path;\n    connections = [ # absolute paths without trailing /\n      {\n        local = \"/home/sid/aud\";\n        remote = \"/aud\";\n      }\n      {\n        local = \"/home/sid/doc\";\n        remote = \"/doc\";\n      }\n      {\n        local = \"/home/sid/img\";\n        remote = \"/img\";\n      }\n      {\n        local = \"/home/sid/vid\";\n        remote = \"/vid\";\n      }\n    ];\n  };\n}\n</code></pre>"},{"location":"modules/home/nextcloud-sync/#usage","title":"Usage","text":"<p>You can manually sync by running:</p> <pre><code>nextcloud-sync-all\n</code></pre> <p>This will synchronize all defined connections.</p>"},{"location":"modules/home/nextcloud-sync/#troubleshooting","title":"Troubleshooting","text":"<p>Each listed connection spawns a systemd user service and timer. Using the example above, we get:</p> <pre><code>nextcloud-sync-aud.service\nnextcloud-sync-aud.timer\nnextcloud-sync-doc.service\nnextcloud-sync-doc.timer\nnextcloud-sync-img.service\nnextcloud-sync-img.timer\nnextcloud-sync-vid.service\nnextcloud-sync-vid.timer\n</code></pre> <p>Check their status to know what might go wrong:</p> <pre><code>systemctl --user status nextcloud-sync-doc.service\njournalctl --user -xeu nextcloud-sync-doc.service\n</code></pre>"},{"location":"modules/home/nixvim/","title":"Nixvim","text":"<p>This module provides some defaults to quickly set up Nixvim with some plugins. </p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/nixvim/#config","title":"Config","text":"<p>Here is an example configuration:</p> <pre><code># flake.nix\ninputs = {\n  nixvim.url = \"github:nix-community/nixvim\";\n  nixvim.inputs.nixpkgs.follows = \"nixpkgs\";\n};\n</code></pre> <pre><code># home/YOU/default.nix\n{ inputs, lib, config, pkgs, ... }:\n\n{\n  imports = [\n    inputs.core.homeModules.stylix # This module works great with stylix\n    inputs.core.homeMmodules.nixvim # You need to import this module\n  ];\n\n  programs.nixvim = {\n    enable = true;\n    #colorschemes.SCHEME.enable = true; # If you do not use the stylix module, set a scheme manually\n    # This module provides defaults for the following plugins.\n    # They are all enabled by default.\n    plugins = {\n      cmp.enable = true; # Auto completion\n      copilot-chat.enable = true; # Chat with GitHub Copilot. Run `:Copilot auth` to authenticate\n      copilot-lua.enable = true; # AI code generation.\n      dap.enable = true; # Debugging \n      lsp.enable = true; # Language server\n      lualine.enable = true; # Statusline\n      luasnip.enable = true; # Coding snippets\n      markdown-preview.enable = true; # Markdown preview in Browser\n      telescope.enable = true; # Fuzzy finder\n      treesitter.enable = true; # Syntax highlighting\n      trouble.enable = true; # Diagnostic messages\n    };\n  };\n\n  stylix = {\n    enable = true;\n    scheme = \"dracula\"; # This automatically sets the nixvim scheme as well\n  };\n}\n</code></pre>"},{"location":"modules/home/nixvim/#keymaps","title":"Keymaps","text":"<p>This module sets some keymaps. Here are some important ones:</p> <p><code>&lt;leader&gt;</code> defaults to the space key</p> key action <code>&lt;leader&gt;pv</code> ex command (file explorer) <code>&lt;leader&gt;s</code> search and replace <code>&lt;C-a&gt;</code> select whole buffer <code>&lt;leader&gt;ss</code> toggle spell checking <code>&lt;leader&gt;se</code> switch to english spell checking <code>&lt;leader&gt;sg</code> switch to german spell checking <code>z=</code> correction suggestions for a misspelled word <code>zg</code> add word to spell list <code>&lt;C-CR&gt;</code> confirm selection in completion menu <code>&lt;C-Tab&gt;</code> select next item in completion menu <code>gd</code> go to definition <code>K</code> display more information about word under cursor <code>&lt;leader&gt;bl</code> list buffers <code>&lt;C-S-J&gt;</code> next buffer <code>&lt;C-S-K&gt;</code> previous buffer <code>&lt;leader&gt;fb</code> or <code>&lt;C-e&gt;</code> open file browser <code>&lt;leader&gt;ff</code> find files by name <code>&lt;leader&gt;fg</code> or <code>&lt;C-f&gt;</code> find files containing string <code>&lt;leader&gt;xd</code> toggle diagnostics <code>&lt;leader&gt;xq</code> toggle quick fix list <code>&lt;leader&gt;ce</code> let copilot explains the selected code <code>&lt;leader&gt;cr</code> let copilot review the selected code <code>&lt;leader&gt;cf</code> let copilot fix the selected code <code>&lt;leader&gt;co</code> let copilot optimize the selected code <code>&lt;leader&gt;cd</code> let copilot comment the selected code <code>&lt;leader&gt;ct</code> let copilot generate tests for the selected code <code>&lt;leader&gt;m</code> run make command <code>&lt;leader&gt;xl</code> toggle loclist list <code>&lt;leader&gt;xx</code> toggle diagnostics list <code>&lt;leader&gt;xq</code> toggle quifick list <code>&lt;C-A-J&gt;</code> previous quickfix item <code>&lt;C-A-K&gt;</code> next quickfix item <p>See keymaps.nix and plugins for more details.</p> <p>These commands do not have keymaps yet but might be useful anyway:</p> command action <code>:CopilotChat &lt;question&gt;</code> ask Copilot a question <code>:MarkdownPreview</code> live render the current markdown buffer"},{"location":"modules/home/password-manager/","title":"Password Manager","text":"<p>This module will automatically install <code>pass</code> as your password manager. It also provides a custom version of <code>passmenu</code> using <code>bemenu</code> for Wayland sessions called <code>passmenu-bemenu</code> and configures passff for your web browser.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/password-manager/#setup","title":"Setup","text":"<p>It is assumed that you have a GPG key.</p>"},{"location":"modules/home/password-manager/#hm-config","title":"HM config","text":"<pre><code>imports = [\n  inputs.core.homeModules.passwordManager\n];\n\nprograms.passwordManager = {\n  enable = true;\n  key = \"YOUR_GPG_KEYGRIP\";\n  wayland = true; # if you are using Wayland\n};\n</code></pre> <p>Get your keygrip with <code>gpg -K --with-keygrip</code></p>"},{"location":"modules/home/password-manager/#password-store","title":"Password Store","text":"<p><code>pass</code> uses a Password Store to manage your password files. If this is your first time using <code>pass</code>, follow option a). If you already have a remote git repository to store your password-store, follow option b).</p>"},{"location":"modules/home/password-manager/#a-initialize-a-new-password-store","title":"a) Initialize a new Password Store","text":"<p>Read the introduction and setup guide on the pass home page.</p>"},{"location":"modules/home/password-manager/#b-cloning-your-remote-password-store-repository","title":"b) Cloning your remote password-store repository","text":"<p>The following guide assumes that you have your private GPG key on a luks encrypted USB partition which is needed to access your remote repo through ssh.</p> <ol> <li>Identify the USB device:    Identify the device name for your USB drive using the <code>lsblk</code> or <code>fdisk -l</code> command.</li> </ol> <pre><code>lsblk\n</code></pre> <p>Look for the device corresponding to your USB drive (e.g., <code>/dev/sdb1</code>).</p> <ol> <li>Unlock the LUKS partition:    Unlock the LUKS partition with the <code>cryptsetup luksOpen</code> command. Replace <code>/dev/sdX1</code> with the actual device name of your USB partition.</li> </ol> <pre><code>sudo cryptsetup luksOpen /dev/sdX1 crypt\n</code></pre> <p>You will be prompted to enter the passphrase for the LUKS partition.</p> <ol> <li>Mount the unlocked partition:    Mount the unlocked LUKS partition to access the files.</li> </ol> <pre><code>sudo mount /dev/mapper/crypt /mnt\n</code></pre> <ol> <li>Import the GPG key:    Use the <code>gpg --import</code> command to import the GPG key from the mounted USB partition.</li> </ol> <pre><code>gpg --import /mnt/path/to/privatekey.gpg\n</code></pre> <ol> <li>Unmount and close the LUKS partition:    After importing the key, unmount the partition and close the LUKS mapping.</li> </ol> <pre><code>sudo umount /mnt\nsudo cryptsetup luksClose crypt\n</code></pre> <ol> <li>Clone your password store repository:    Clone your password store repository using the <code>git clone</code> command, for example:</li> </ol> <pre><code>git clone ssh://example.tld:/home/you/git/password-store.git ~/.local/share/password-store\n</code></pre>"},{"location":"modules/home/sops/","title":"Sops","text":"<p>For more information on how to use this module, see the Sops NixOS module documentation.</p> <p>For extensive documentation, read the Readme on GitHub.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/sops/#1-generate-an-age-key","title":"1. Generate an age key","text":"<pre><code>mkdir -p ~/.config/sops/age\nage-keygen -o ~/.config/sops/age/keys.txt\n</code></pre> <p>Take note of your public key. You can print it again with:  <code>age-keygen -y ~/.config/sops/age/keys.txt</code></p>"},{"location":"modules/home/sops/#2-edit-sopsyaml","title":"2. Edit <code>.sops.yaml</code>","text":"<p>This file manages access to all secrets in this repository (NixOS and Home Manager configurations).</p> <pre><code>vim ~/.config/nixos/.sops.yaml\n</code></pre> <p>Add your public key under <code>keys</code> and set creation rules for your config:</p> <pre><code>keys:\n  - &amp;you age12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl\ncreation_rules:\n  - path_regex: users/you/home/secrets/secrets.yaml$\n    key_groups:\n    - age:\n      - *you\n</code></pre>"},{"location":"modules/home/sops/#3-create-a-secrets-directory","title":"3. Create a <code>secrets</code> directory","text":"<p>This directory in your Home Manager configuration will hold your secrets and sops configuration.</p> <pre><code>mkdir -p ~/.config/nixos/users/$(whoami)/home/secrets\n</code></pre>"},{"location":"modules/home/sops/#4-create-a-sops-file","title":"4. Create a sops file","text":"<p>A sops file contains secrets in plain text. This file will then be encrypted with age. Make sure to follow the path regex in the creation rules.</p> <pre><code>cd ~/.config/nixos\nsops users/$(whoami)/home/secrets/secrets.yaml\n</code></pre> <pre><code># Files must always have a string value\nexample-key: example-value\n# Nesting the key results in the creation of directories.\nmyservice:\n  my_subdir:\n    my_secret: password1\n</code></pre>"},{"location":"modules/home/sops/#5-deploy-the-secrets-to-the-nix-store","title":"5. Deploy the secrets to the Nix store","text":"<p>Define your secrets under <code>sops.secrets</code>.</p> <pre><code>vim ~/.config/nixos/users/$(whoami)/home/secrets/default.nix\n</code></pre> <pre><code>{\n  sops.secrets.example-key = {};\n  sops.secrets.\"myservice/my_subdir/my_secret\" = {};\n}\n</code></pre>"},{"location":"modules/home/sops/#6-reference-secrets-in-your-home-manager-configuration","title":"6. Reference secrets in your Home Manager configuration","text":"<p>Now you can use these secrets in your Home Manager configuration:</p> <pre><code>{ outputs, ... }:\n\n{\n  imports = [\n    ./secrets\n\n    outputs.homeModules.sops # includes all necessary configuration for sops-nix\n  ];\n\n  someOption.secretFile = config.sops.secrets.example-key.path;\n\n  anotherOption.passwordFile = config.sops.secrets.\"myservice/my_subdir/my_secret\".path;\n}\n</code></pre>"},{"location":"modules/home/stylix/","title":"Stylix","text":"<p>This module wraps stylix, a theming framework for NixOS, Home Manager, nix-darwin, and Nix-on-Droid.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/stylix/#references","title":"References","text":"<ul> <li>docs</li> </ul>"},{"location":"modules/home/stylix/#usage","title":"Usage","text":"<p>Add stylix to your flake inputs:</p> <pre><code>inputs = {\n  stylix.url = \"github:nix-community/stylix\";\n  stylix.inputs.nixpkgs.follows = \"nixpkgs\";\n};\n</code></pre> <p>For example, in your home configuration, set:</p> <pre><code>imports = [ inputs.core.homeModules.stylix ];\n\nstylix = {\n  enable = true;\n  scheme = \"SCHEME\";\n};\n</code></pre> <p>Replace <code>SCHEME</code> with the name of your scheme. Available schemes are listed as <code>validSchemes</code> in our stylix module.</p>"},{"location":"modules/home/stylix/#create-a-scheme","title":"Create a scheme","text":"<p>You can create your own scheme in <code>schemes/&lt;scheme&gt;.yaml</code>. To make it available via <code>stylix.scheme</code>, you need to add it to <code>validSchemes</code> and <code>customSchemes</code> in the module's <code>default.nix</code>. Make sure that the resulting scheme name is a valid colorscheme in nixvim.</p> <p>It is recommended to set colors according to their purpose / name. This means that <code>base00</code> should always be a rather dark color for the background and <code>base08</code> a reddish color.</p> <pre><code># &lt;scheme&gt;.yaml\nsystem: \"base16\"\nname: \"SCHEME\"\nauthor: \"AUTHOR\"\ndescription: \"A dark theme inspired by the SCHEME color scheme.\"\nslug: \"SCHEME-theme\"\nvariant: \"dark\"\npalette:\n  base00: \"080808\" # background\n  base01: \"323437\" # alternate background\n  base02: \"9e9e9e\" # selection background\n  base03: \"bdbdbd\" # comments\n  base04: \"b2ceee\" # alternate text\n  base05: \"c6c6c6\" # default text\n  base06: \"e4e4e4\" # light foreground\n  base07: \"eeeeee\" # light background\n  base08: \"ff5454\" # error / red\n  base09: \"cf87e8\" # urgent / orange\n  base0A: \"8cc85f\" # warning / yellow\n  base0B: \"e3c78a\" # green\n  base0C: \"79dac8\" # cyan\n  base0D: \"80a0ff\" # blue\n  base0E: \"36c692\" # magenta\n  base0F: \"74b2ff\" # brown\n</code></pre> <p>Refer to Stylix's style guide for more information on where and how these colors will be used.</p> <p>You can preview your color schemes with the base16-viewer (Disable your dark reader) or <code>print-colors</code> - a Python script to view color schemes in the terminal:</p> <pre><code>print-colors PATH/TO/colors.yaml\n</code></pre>"},{"location":"modules/home/stylix/#wallpaper","title":"Wallpaper","text":"<p>You can set a wallpaper with:</p> <pre><code>stylix.image = ./path/to/wallpaper.png;\n</code></pre> <p>This can be any image as a PNG file. You might want to take a look at some Nix themed wallpapers or nix-wallpaper to create your own wallpaper with the Nix logo and custom colors.</p> <p>Or create a solid color image with:</p> <pre><code>convert -size 3840x2160 \"xc:#080808\" wallpaper.png\n</code></pre>"},{"location":"modules/home/virtualisation/","title":"Virtualisation","text":"<p>Home Manager module to go with the Virtualisation NixOS module.</p> <p>View the nix-core Home Manager module on GitHub.</p>"},{"location":"modules/home/virtualisation/#setup","title":"Setup","text":"<ol> <li>Import this module in your Home Manager configuration and the corresponding NixOS module in your NixOS configuration.</li> <li>Rebuild and reboot: <code>rebuild all &amp;&amp; sudo reboot now</code></li> <li>Start the default network: <code>virsh net-autostart default</code></li> </ol>"},{"location":"modules/home/waybar/","title":"Waybar","text":"<p>Waybar is a highly customizable Wayland bar for Sway and Wlroots based compositors.</p> <p>View the nix-core Home Manager module on GitHub. If you use this repository's Hyprland module, it is enabled by default.</p>"},{"location":"modules/home/waybar/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/home/yazi/","title":"yazi","text":"<p>Terminal file manager written in Rust.</p> <p>View the nix-core Home Manager module on GitHub. If you use this repository's Hyprland module, it is enabled by default.</p>"},{"location":"modules/home/yazi/#references","title":"References","text":"<ul> <li>GitHub</li> <li>docs</li> <li>default keybindings</li> <li>Plugins in Nixpkgs</li> </ul>"},{"location":"modules/nixos/audio/","title":"Audio","text":"<p>PipeWire is a server for handling audio, video streams, and hardware on Linux.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/audio/#references","title":"References","text":"<ul> <li>Homepage</li> </ul>"},{"location":"modules/nixos/baibot/","title":"Baibot","text":"<p>Baibot is a Matrix AI bot.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/baibot/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/nixos/baibot/#setup","title":"Setup","text":""},{"location":"modules/nixos/baibot/#configuration","title":"Configuration","text":"<p>Since baibot's configuration file requires setting secrets as plain text strings, configuring the baibot service through Nix is not supported. You have to create a configuration file on your machine and point to it with <code>services.baibot.configFile</code>. </p> <p>Use the template configuration file for reference.</p>"},{"location":"modules/nixos/baibot/#user-creation","title":"User Creation","text":"<p>Create the <code>baibot</code> user on your Matrix instance. If you are using the nix-core Matrix module, this can be done with the <code>register_new_matrix_user</code> alias:</p> <pre><code>register_new_matrix_user\n</code></pre> <p>Set the <code>user localpart</code> and <code>password</code> according to your configuration.</p> <p>Restart both <code>matrix-synapse.service</code> and <code>baibot.service</code>. You can then invite Baibot to any room you like.</p>"},{"location":"modules/nixos/baibot/#openai-api","title":"OpenAI API","text":"<p>Send this message in a room where Baibot has joined:</p> <pre><code>!bai agent create-global openai openai\n</code></pre> <p>The bot will reply with a YAML configuration which you need to edit and send back:</p> <pre><code>base_url: https://api.openai.com/v1\napi_key: YOUR_API_KEY_HERE\ntext_generation:\n  model_id: gpt-4o\n  prompt: 'You are a brief, but helpful bot called {{ baibot_name }} powered by the {{ baibot_model_id }} model. The date/time of this conversation''s start is: {{ baibot_conversation_start_time_utc }}.'\n  temperature: 1.0\n  max_response_tokens: 16384\n  max_context_tokens: 128000\nspeech_to_text:\n  model_id: whisper-1\ntext_to_speech:\n  model_id: tts-1-hd\n  voice: onyx\n  speed: 1.0\n  response_format: opus\nimage_generation:\n  model_id: dall-e-3\n  style: vivid\n  size: 1024x1024\n  quality: standard\n</code></pre> <p>Set <code>openai</code> as the default for any purpose you like:</p> <pre><code>!bai config global set-handler text-generation global/openai\n!bai config global set-handler speech-to-text global/openai\n!bai config global set-handler text-to-speech global/openai\n!bai config global set-handler image-generation global/openai\n</code></pre>"},{"location":"modules/nixos/baibot/#tips","title":"Tips","text":""},{"location":"modules/nixos/baibot/#set-stt-to-transcribe-only","title":"Set STT to Transcribe Only","text":"<pre><code>!bai config global speech-to-text set-flow-type only_transcribe\n</code></pre>"},{"location":"modules/nixos/baibot/#set-user-access","title":"Set user access","text":"<pre><code>!bai access set-users SPACE_SEPARATED_PATTERNS\n</code></pre> <p>For example: <code>@*:example.com</code></p>"},{"location":"modules/nixos/baibot/#todo","title":"Todo","text":"<ol> <li>Set up a local LLM for speech-to-text with Ollama.</li> <li>Whitelist each user for the speech-to-text engine only.</li> </ol>"},{"location":"modules/nixos/cifsmount/","title":"cifsMount","text":"<p>Warning: This module is not actively maintained. Expect things to break!</p> <p>This module allows you to automount cifs shares after the login of the specified user. The remote has to have a running samba server.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/cifsmount/#config","title":"Config","text":"<pre><code>config.services.cifsMount = {\n  enable = true;\n  remotes = [\n    {\n      host = \"ip_address\";\n      shareName = \"share_name\";\n      mountPoint = \"/home/user/mount_point\";\n      credentialsFile = \"/home/user/.smbcredentials\";\n      user = \"user\";\n    }\n    # more remotes ...\n  ];\n};\n</code></pre>"},{"location":"modules/nixos/common/","title":"Common","text":"<p>The common module sets some opinionated defaults.</p> <p>View the nix-core NixOS module on GitHub.</p> <p>It is recommended to import it in your NixOS configuration as some nix-core modules may depend on it:</p> <pre><code>{ inputs, ... }:\n\n{\n  imports = [\n    inputs.core.nixosModules.common\n  ];\n}\n</code></pre>"},{"location":"modules/nixos/device/","title":"Device","text":"<p>This module lets you set some defaults for a device type.</p> <p>View the nix-core NixOS module on GitHub.</p> <p>Available devices are:</p> <ul> <li>laptop</li> <li>vm</li> </ul> <p>To enable these defaults, you need to import this module in your host configuration. For example:</p> <pre><code># hosts/HOSTNAME/default.nix\n\nimports = [ inputs.core.nixosModules.device.vm ]; # this imports all defaults for VMs. See `vm.nix`\n</code></pre>"},{"location":"modules/nixos/firefly-iii/","title":"Firefly III and Firefly III data importer","text":"<p>A free and open source personal finance manager.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/firefly-iii/#references","title":"References","text":"<ul> <li>Documentation</li> </ul>"},{"location":"modules/nixos/firefly-iii/#firefly-iii","title":"Firefly III","text":"<ul> <li>GitHub</li> <li>Configuration example</li> </ul>"},{"location":"modules/nixos/firefly-iii/#firefly-iii-data-importer","title":"Firefly III data importer","text":"<ul> <li>GitHub</li> <li>Configuration example</li> </ul>"},{"location":"modules/nixos/firefly-iii/#sops","title":"Sops","text":"<p>Provide the following entries to your host's <code>secrets.yaml</code>:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>firefly-iii:\n    appkey: abc123 # for `services.firefly-iii.settings.APP_KEY_FILE`\n    smtp-password: abc123\n    hashed-smtp-password: abc123\n</code></pre>"},{"location":"modules/nixos/firefly-iii/#generate-your-app-key-with","title":"Generate your app key with:","text":"<pre><code>head -c 32 /dev/urandom | base64\n</code></pre>"},{"location":"modules/nixos/firefly-iii/#generate-the-hashed-smtp-password-with","title":"Generate the hashed SMTP password with:","text":"<pre><code>nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'\n</code></pre> <p>For more info, see our mailserver module.</p>"},{"location":"modules/nixos/firefly-iii/#setup","title":"Setup","text":"<p>Set CNAME records for your Firefly III and Firefly III data importer subdomains pointing to your domain.</p>"},{"location":"modules/nixos/firefly-iii/#firefly-iii_1","title":"Firefly III","text":"<ol> <li>Visit \"SUBDOMAIN.DOMAIN.TLD\" in a browser.</li> <li>Create an admin account.</li> <li>Follow the on screen guide \"Getting started\".</li> <li>Create a OAuth client for your data importer instance.<ol> <li>Go to <code>Options</code> &gt; <code>Profile</code> &gt; <code>OAuth</code></li> <li>Click <code>Create New Client</code><ul> <li>Name: Can be anything</li> <li>Redirect URL: <code>https://IMPORTER_SUBDOMAIN.DOMAIN.TLD/callback</code></li> <li>Confidential: Uncheck</li> </ul> </li> <li>Click <code>Create</code>. Take note of the Client ID.</li> </ol> </li> </ol>"},{"location":"modules/nixos/firefly-iii/#firefly-iii-data-importer_1","title":"Firefly III data importer","text":"<ol> <li>Visit <code>IMPORTER_SUBDOMAIN.DOMAIN.TLD</code> in a browser.<ul> <li>Firefly III URL: <code>https://SUBDOMAIN.DOMAIN.TLD</code></li> <li>Client ID: Client ID from above</li> </ul> </li> <li>Click <code>Submit</code></li> <li>Click <code>Authorize</code></li> </ol>"},{"location":"modules/nixos/ftp-webserver/","title":"FTP web server","text":"<p>Warning: This module is not actively maintained. Expect things to break!</p> <p>This module sets up a simple ftp web server behind a reverse proxy (<code>ftp.domain.tld</code> by default).</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/gitea/","title":"Gitea","text":"<p>Gitea is a forge software package for hosting software development version control using Git.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/gitea/#references","title":"References","text":"<ul> <li>docs</li> </ul>"},{"location":"modules/nixos/gitea/#administration","title":"Administration","text":"<p>cli docs</p> <p><code>gitea</code> is aliased to <code>sudo -u gitea gitea --config /var/lib/gitea/custom/conf/app.ini</code></p> <p>Add a user:</p> <pre><code>gitea admin user create -u USER -p PASSWORD --email USER@sid.ovh [--admin]\n</code></pre> <p>Change user password:</p> <pre><code>gitea admin user change-password -u USER -p PASSWORD\n</code></pre>"},{"location":"modules/nixos/headplane/","title":"Headplane","text":"<p>A feature-complete Web UI for Headscale.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/headplane/#references","title":"References","text":"<ul> <li>Website</li> <li>GitHub</li> <li>NixOS options</li> </ul>"},{"location":"modules/nixos/headplane/#sops","title":"Sops","text":"<p>Provide the following entries to your <code>secrets.yaml</code>:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>headplane:\n    cookie_secret: abc123\n    agent_pre_authkey: abc123\n</code></pre> <p>Generate your cookie secret with:</p> <pre><code>nix-shell -p openssl --run \"openssl rand -hex 16\"\n</code></pre> <p>Generate your agent pre-authkey with:</p> <pre><code>sudo headscale users create headplane-agent\nsudo headscale users list # get headplane-agent user id\nsudo headscale preauthkeys create --expiration 99y --reusable --user &lt;HEADPLANE-AGENT-ID&gt;\n</code></pre>"},{"location":"modules/nixos/headplane/#setup","title":"Setup","text":"<p>Set a CNAME record for your Headplane subdomain (<code>headplane</code> by default) pointing to your domain.</p>"},{"location":"modules/nixos/headplane/#config","title":"Config","text":"<pre><code># flake.nix\nheadplane.url = \"github:tale/headplane\";\nheadplane.inputs.nixpkgs.follows = \"nixpkgs\";\n</code></pre> <pre><code># configuration.nix\n{\n  imports = [ inputs.core.nixosModules.headplane ];\n\n  services.headplane = {\n    enable = true;\n  };\n}\n</code></pre>"},{"location":"modules/nixos/headplane/#usage","title":"Usage","text":"<p>Create a Headscale API key:</p> <pre><code>sudo headscale apikeys create\n</code></pre> <p>Visit the admin login page: <code>https://sub.domain.tld/admin/login</code></p>"},{"location":"modules/nixos/headscale/","title":"Headscale","text":"<p>Headscale is an open source, self-hosted implementation of the Tailscale control server.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/headscale/#references","title":"References","text":"<ul> <li>Website</li> <li>GitHub</li> <li>Example configuration file</li> </ul>"},{"location":"modules/nixos/headscale/#setup","title":"Setup","text":"<p>Set a CNAME record for your Headscale subdomain (<code>headscale</code> by default) pointing to your domain.</p>"},{"location":"modules/nixos/headscale/#config","title":"Config","text":"<pre><code>{\n  imports = [ inputs.core.nixosModules.headscale ];\n\n  services.headscale = {\n    enable = true;\n    openFirewall = true;\n  };\n}\n</code></pre>"},{"location":"modules/nixos/headscale/#usage","title":"Usage","text":"<p>Create a new user:</p> <pre><code>sudo headscale users create &lt;USER&gt;\n</code></pre> <p>Get the user's id:</p> <pre><code>sudo headscale users list\n</code></pre> <p>Create a pre auth key for that user:</p> <pre><code>sudo headscale preauthkeys create --expiration 99y --reusable --user &lt;ID&gt;\n</code></pre> <p>Give the user the pre-auth key.</p>"},{"location":"modules/nixos/headscale/#troubleshooting","title":"Troubleshooting","text":"<p>Check if your ACL config is valid:</p> <pre><code>sudo headscale policy check --file PATH/TO/acl.hujson\n</code></pre>"},{"location":"modules/nixos/hydra/","title":"Hydra","text":"<p>Hydra is a Continuous Integration service for Nix based projects.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/hydra/#references","title":"References","text":"<ul> <li>GitHub</li> <li>docs</li> <li>NixOS Wiki</li> </ul>"},{"location":"modules/nixos/hydra/#setup","title":"Setup","text":"<p>Create an admin user:</p> <pre><code>sudo -u hydra hydra-create-user YOU --full-name YOU --email-address 'YOU@EXAMPLE.TLD' --password-prompt --role admin\n</code></pre>"},{"location":"modules/nixos/hydra/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml for email support:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>hydra:\n    smtp-password: abc123 # for email support (local or external mailserver)\n    hashed-smtp-password: abc123 # for email support (local mailserver only)\n</code></pre> <p>Generate the hashed password with:</p> <pre><code>nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'\n</code></pre> <p>For more info, see our mailserver module.</p>"},{"location":"modules/nixos/i2pd/","title":"I2P Daemon","text":"<p>I2P is an End-to-End encrypted and anonymous Internet.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/i2pd/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Documentation</li> <li>GitHub</li> <li>I2P on NixOS guide</li> </ul>"},{"location":"modules/nixos/i2pd/#configuration","title":"Configuration","text":""},{"location":"modules/nixos/i2pd/#nixos","title":"NixOS","text":"<pre><code>{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.i2pd ];\n\n  services.i2pd.enable = true;\n}\n</code></pre>"},{"location":"modules/nixos/immich/","title":"Immich","text":"<p>Self-hosted photo and video management solution.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/immich/#references","title":"References","text":"<ul> <li>GitHub</li> <li>Docs</li> <li>Default config file</li> </ul>"},{"location":"modules/nixos/immich/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>immich:\n    db-pasword: abc123\n</code></pre>"},{"location":"modules/nixos/immich/#setup","title":"Setup","text":"<p>Set a CNAME record for your Immich subdomain (<code>gallery</code> by default) pointing to your domain.</p>"},{"location":"modules/nixos/immich/#config","title":"Config","text":"<pre><code>{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.immich ];\n\n  services.immich = {\n    enable = true;\n  };\n}\n</code></pre>"},{"location":"modules/nixos/immich/#first-launch","title":"First launch","text":"<p>Visit the web interface to create an admin account.</p>"},{"location":"modules/nixos/instaloader/","title":"Instaloader","text":"<p>Instaloader is a tool to download pictures (or videos) along with their captions and other metadata from Instagram. This module wraps instaloader in a systemd service for periodic downloads.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/instaloader/#references","title":"References","text":"<ul> <li>GitHub</li> <li>docs</li> </ul>"},{"location":"modules/nixos/instaloader/#troubleshooting","title":"Troubleshooting","text":""},{"location":"modules/nixos/instaloader/#password-authentication-does-not-work","title":"Password authentication does not work","text":"<p>This is a known issue in version 4.14.x. You should provide a session file containing a browser cookie:</p> <ol> <li>Install instaloader (the package is sufficient) on your client machine.</li> <li>Log into Instagram in any Firefox based browser. Here, LibreWolf is used.</li> <li>Load cookies: <code>instaloader --load-cookies LibreWolf</code></li> <li>Copy your session file to your server running the nix-core instaloader module:<ul> <li>From: <code>~/.config/instaloader/session-&lt;your_ig_user&gt;</code></li> <li>To: <code>/var/lib/instaloader/.config/session-&lt;your_ig_user&gt;</code></li> </ul> </li> </ol> <p>See this issue for more information.</p>"},{"location":"modules/nixos/jellyfin/","title":"Jellyfin","text":"<p>Jellyfin is a free and open-source media server and suite of multimedia applications.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/jellyfin/#references","title":"References","text":"<p>docs</p>"},{"location":"modules/nixos/jellyfin/#setup","title":"Setup","text":"<p>Users, Plugins, and Libraries are managed in the web interface. You have to declare them manually.</p> <p>Visit the web interface and follow the on screen instructions. Create libraries corresponding to <code>config.services.jellyfin.libraries</code>.</p>"},{"location":"modules/nixos/jellyfin/#upload-files","title":"Upload files","text":"<pre><code>rsync -arvzP -e 'ssh -p SSH_PORT' LOCAL_PATH YOU@REMOTE:JELLYFIN_DATA_DIR/libraries/LIBRARY\n</code></pre> <p>the user <code>YOU</code> has to be in the jellyfin group on the remote machine <code>REMOTE</code></p> <ul> <li><code>SSH_PORT</code>: Your SSH port</li> <li><code>LOCAL_PATH</code>: Local path to your media file(s)</li> <li><code>YOU</code>: Your user on your remote machine</li> <li><code>REMOTE</code>: IP/domain of your remote machine</li> <li><code>JELLYFIN_DATA_DIR</code>: <code>config.services.jellyfin.dataDir</code></li> <li><code>LIBRARY</code>: Target library. See <code>config.services.jellyfin.libraries</code></li> </ul>"},{"location":"modules/nixos/jirafeau/","title":"Jirafeau","text":"<p>Jirafeau is a project that allows \"one-click filesharing\", making it easy to upload a file and give it a unique link.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/jirafeau/#references","title":"References","text":"<ul> <li>docs</li> </ul>"},{"location":"modules/nixos/mailserver/","title":"Mail","text":"<p>A simple NixOS mailserver.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/mailserver/#references","title":"References","text":"<ul> <li>docs</li> </ul>"},{"location":"modules/nixos/mailserver/#setup","title":"Setup","text":"<p>Follow the setup guide.</p>"},{"location":"modules/nixos/mailserver/#config","title":"Config","text":""},{"location":"modules/nixos/mailserver/#flakenix","title":"<code>flake.nix</code>","text":"<pre><code>inputs = {\n  nixos-mailserver.url = \"gitlab:simple-nixos-mailserver/nixos-mailserver\";\n  nixos-mailserver.inputs.nixpkgs.follows = \"nixpkgs\";\n};\n</code></pre>"},{"location":"modules/nixos/mailserver/#host-configuration","title":"Host configuration:","text":"<pre><code>imports = [ inputs.core.nixosModules.mailserver ]\n\nmailserver = {\n  enable = true;\n  loginAccounts = {\n    \"ADMIN@${config.networking.domain}\" = {\n      # nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'\n      hashedPasswordFile = config.sops.secrets.\"mailserver/accounts/ADMIN\".path;\n      aliases = [ \"postmaster@${config.networking.domain}\" ];\n    };\n  };\n};\nsops.secrets.\"mailserver/accounts/ADMIN\" = { };\n</code></pre> <p>Replace <code>ADMIN</code> with an existing administrator account.</p> <p>You may need to set <code>mailserver.stateVersion</code>. At the time of writing, you need to set it to <code>3</code>, but you should check the mailserver docs yourself.</p>"},{"location":"modules/nixos/matrix-synapse/","title":"Matrix-Synapse","text":"<p>Synapse is a Matrix homeserver. Matrix is an open network for secure, decentralised communication.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/matrix-synapse/#references","title":"References","text":"<ul> <li>repo</li> <li>docs</li> <li>coturn</li> </ul>"},{"location":"modules/nixos/matrix-synapse/#setup","title":"Setup","text":""},{"location":"modules/nixos/matrix-synapse/#dns","title":"DNS","text":"<p>Make sure you have a CNAME record for <code>turn</code> pointing to your domain.</p>"},{"location":"modules/nixos/matrix-synapse/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secret(s)</p> <p><pre><code>coturn:\n    static-auth-secret: abc123\nmatrix:\n    registration-shared-secret: abc123\nlivekit:\n    key: abc123\n</code></pre> Generate the livekit key with:</p> <pre><code>nix-shell -p livekit --run \"livekit-server generate-keys | tail -1 | awk '{print $3}'\"\n</code></pre>"},{"location":"modules/nixos/matrix-synapse/#config","title":"Config","text":"<pre><code>{\n  imports = [inputs.core.nixosModules.matrix-synapse ];\n\n  networking.domain = \"example.tld\";\n\n  services.matrix-synapse = {\n    enable = true;\n    # see below\n    bridges = {\n      whatsapp = {\n        enable = true;\n        admin = \"@you:example.tld\";\n      };\n      signal = {\n        enable = true;\n        admin = \"@you:example.tld\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"modules/nixos/matrix-synapse/#bridges","title":"Bridges","text":"<p>Warning: Bridges use <code>mautrix-go</code> which relies on deprecated <code>libolm</code>.</p>"},{"location":"modules/nixos/matrix-synapse/#sops_1","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secret(s) and <code>BRIDGE</code> with the name of your bridge (e.g., <code>whatsapp</code> or <code>signal</code>)</p> <pre><code>mautrix-BRIDGE:\n    encryption-pickle-key: abc123\n    provisioning-shared-secret: abc123\n    public-media-signing-key: abc123\n    direct-media-server-key: abc123\n</code></pre> <p>Generate the secrets with:</p> <pre><code>nix-shell -p openssl --run \"openssl rand -base64 32\"\n</code></pre>"},{"location":"modules/nixos/matrix-synapse/#nixos-configuration","title":"NixOS configuration","text":"<p>The <code>config.yaml</code> for each bridge is managed through <code>services.mautrix-BRIDGE.settings</code>:</p> <ul> <li>services.mautrix-signal.settings: Generate an example config with: <code>mautrix-signal -c signal.yaml --generate-example-config</code></li> <li>services.mautrix-whatsapp.settings: Generate an example config with: <code>mautrix-whatsapp -c whatsapp.yaml --generate-example-config</code></li> </ul>"},{"location":"modules/nixos/matrix-synapse/#authentication","title":"Authentication","text":"<ol> <li>Open chat with bridge bot: <code>@BOT:DOMAIN.TLD</code><ul> <li>WhatsApp: <code>whatsappbot</code></li> <li>Signal: <code>signalbot</code></li> </ul> </li> <li>Send: <code>login qr</code></li> <li>Scan QR code</li> <li>Switch puppets: <code>login-matrix ACCESS_TOKEN</code><ul> <li>Get your token with: Settings &gt; Help &amp; About &gt; Advanced &gt; Access Token</li> </ul> </li> </ol>"},{"location":"modules/nixos/matrix-synapse/#administration","title":"Administration","text":""},{"location":"modules/nixos/matrix-synapse/#register-users","title":"Register users","text":"<pre><code>register_new_matrix_user -u USERNAME -p PASSWORD\n</code></pre>"},{"location":"modules/nixos/matrix-synapse/#troubleshooting","title":"Troubleshooting","text":""},{"location":"modules/nixos/matrix-synapse/#bridges-specified-admin-user-is-not-an-admin-in-portal-rooms","title":"Bridges: Specified admin user is not an admin in portal rooms","text":"<p>There seems to be a bug that the user specified under <code>services.matrix-synapse.bridges.whatsapp.admin</code> does not have admin permissions in portal rooms. You can set the power level manually inside each portal room:</p> <pre><code>!wa set-pl @YOU:DOMAIN.TLD 100\n</code></pre>"},{"location":"modules/nixos/mcpo/","title":"mcpo","text":"<p>A simple MCP-to-OpenAPI proxy server.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/mcpo/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/nixos/mcpo/#configuration","title":"Configuration","text":"<p>You have to provide a package, for example from nix-core.</p> <p>Setting <code>mcpServers</code> is required. The following example runs a NixOS MCP server using mcp-nixos.</p> <pre><code>{ inputs, lib, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.mcpo ];\n\n  services.mcpo = {\n    enable = true;\n    package = inputs.core.packages.${pkgs.system}.mcpo;\n    settings = {\n      mcpServers = {\n        nixos = {\n          command = lib.getExe inputs.mcp-nixos.packages.${pkgs.system}.mcp-nixos;\n        };\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"modules/nixos/mcpo/#usage","title":"Usage","text":"<p>Each tool will be accessible under its own unique route <code>127.0.0.1:8000/&lt;mcp-server&gt;</code>. Following the example from above, visit 127.0.0.1:8000/nixos/docs to send requests manually.</p>"},{"location":"modules/nixos/mcpo/#open-webui-integration","title":"Open WebUI Integration","text":"<p>Follow the official Open WebUI integration documentation starting at Step 2.</p> <p>In Open WebUI, users have to set Function Calling to Native in Settings &gt; General &gt; Advanced Parameters. Then, they can enable MCP servers in a chat by clicking More (the plus sign) in the bottom left of the prompt window.</p>"},{"location":"modules/nixos/miniflux/","title":"Miniflux","text":"<p>Miniflux is a minimalist and opinionated feed reader.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/miniflux/#references","title":"References","text":"<ul> <li>Website</li> <li>GitHub</li> <li>Configuration parameters</li> </ul>"},{"location":"modules/nixos/miniflux/#setup","title":"Setup","text":""},{"location":"modules/nixos/miniflux/#dns","title":"DNS","text":"<p>Make sure you have a CNAME record for Miniflux's subdomain (<code>rss</code> by default) pointing to your domain.</p>"},{"location":"modules/nixos/miniflux/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secret(s)</p> <pre><code>miniflux:\n    admin-password: abc123\n</code></pre>"},{"location":"modules/nixos/miniflux/#config","title":"Config","text":"<pre><code>{\n  imports = [inputs.core.nixosModules.miniflux ];\n\n  services.miniflux = {\n    enable = true;\n    reverseProxy.enable = true;\n    reverseProxy.subdomain = \"rss\";\n  };\n}\n</code></pre>"},{"location":"modules/nixos/nextcloud/","title":"Nextcloud","text":"<p>Nextcloud is an open source content collaboration platform and file hosting service.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/nextcloud/#references","title":"References","text":"<ul> <li>homepage</li> <li>docs</li> </ul>"},{"location":"modules/nixos/nextcloud/#setup","title":"Setup","text":"<ul> <li>Login as the default admin user \"nextcloud\" with the same password.</li> <li>Create a new user and add \"admin\" under \"Groups\" to make him an admin user.</li> <li>Log out and in as the new user.</li> <li>Delete the user \"nextcloud\".</li> </ul>"},{"location":"modules/nixos/nextcloud/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml for email support:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>nextcloud:\n    smtp-password: abc123 # for email support (local or external mailserver)\n    hashed-smtp-password: abc123 # for email support (local mailserver only)\n</code></pre> <p>Generate the hashed password with:</p> <pre><code>nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'\n</code></pre> <p>For more info, see our mailserver module.</p>"},{"location":"modules/nixos/nextcloud/#config","title":"Config","text":""},{"location":"modules/nixos/nextcloud/#apps","title":"Apps","text":"<p>Installing apps via the web interface is disabled. You have to use <code>services.nextcloud.extraApps</code>.</p> <p>Configuring them works as usual in the web interface.</p>"},{"location":"modules/nixos/nextcloud/#maintenance","title":"Maintenance","text":""},{"location":"modules/nixos/nextcloud/#admin-cli","title":"Admin CLI","text":"<p>Use Nextcloud's <code>occ</code> command for server operations. On NixOS, it is available under the wrapper script <code>nextcloud-occ</code>. Refer to the Nextcloud docs on how to use the <code>occ</code> command, especially the Maintenance commands. Here are some useful commands:</p> <ul> <li>General housekeeping: <code>sudo nextcloud-occ maintenance:repair --include-expensive</code></li> </ul>"},{"location":"modules/nixos/nextcloud/#logging","title":"Logging","text":"<p>Nextcloud's logs are handled through systemd. Relevant services are:</p> <ul> <li><code>phpfpm-nextcloud.service</code>: PHP-FPM processes that run the Nextcloud application code - application-level logs</li> <li><code>nextcloud-cron.service</code>: Runs Nextcloud's background jobs and maintenance tasks - cron job execution logs</li> <li><code>nginx.service</code>: Web server that handles HTTP requests - access and connection logs</li> </ul> <p>You can check these logs with:</p> <pre><code>journalctl -u SERVICE\n</code></pre> <p>These flags might be useful:</p> <ul> <li><code>-p err</code>: Show only error-level messages and above</li> <li><code>-f</code>: Follow logs in real-time</li> <li><code>--since today</code>: Show logs from today onwards</li> </ul>"},{"location":"modules/nixos/nix-serve/","title":"nix-serve","text":"<p>Standalone Nix binary cache server.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/nix-serve/#references","title":"References","text":"<ul> <li>NixOS Community Wiki</li> </ul>"},{"location":"modules/nixos/nix-serve/#setup","title":"Setup","text":"<p>Generate binary cache key pair:</p> <pre><code>nix-store --generate-binary-cache-key SUBDOMAIN.EXAMPLE.TLD cache-priv-key.pem cache-pub-key.pem\n</code></pre> <p>Publishing the public key will allow anybody to use your server as a binary cache. Keep the private key secret.</p>"},{"location":"modules/nixos/nix-serve/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml for email support:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>hydra:\n    cache-priv-key: abc123 # only the string between `:` and `==`\n</code></pre>"},{"location":"modules/nixos/nix-serve/#troubleshooting","title":"Troubleshooting","text":"<p>Check the general availability of your cache server:</p> <pre><code>curl https://SUBDOMAIN.EXAMPLE.TLD/nix-cache-info\n</code></pre>"},{"location":"modules/nixos/normalUsers/","title":"Normal Users","text":"<p>This module automates user creation for normal users.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/normalUsers/#config","title":"Config","text":"<p>For example:</p> <pre><code>imports = [ inputs.core.nixosModules.normalUsers ]\n\nconfig.normalUsers = {\n  alice = {\n    extraGroups = [ \"wheel\" ];\n    sshKeyFiles = [ ../../users/alice/pubkeys/id_rsa.pub ];\n  };\n};\n</code></pre>"},{"location":"modules/nixos/ntfy-sh/","title":"ntfy-sh notifiers","text":"<p>Collection of notifiers for ntfy-sh.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/ntfy-sh/#references","title":"References","text":"<ul> <li>ntfy-sh docs</li> <li>GitHub repo</li> </ul>"},{"location":"modules/nixos/ntfy-sh/#setup","title":"Setup","text":"<p>Import and enable the module:</p>"},{"location":"modules/nixos/ntfy-sh/#server","title":"Server","text":"<pre><code>imports = [ inputs.core.nixosModules.ntfy-sh ]\n\nservices.ntfy-sh = {\n  enable = true;\n  reverseProxy.enable = true;\n  settings.base-url = \"https://ntfy.example.tld\";\n  # add notifiers. See `default.nix`\n  notifiers = {\n    # your FQDNs need working HTTPS\n    monitor-domains = [\n      {\n        fqdn = \"foo.bar\";\n        topic = \"foo-bar\";\n      }\n    ];\n  };\n};\n</code></pre> <p>Add a CNAME record for ntfy.example.tld to point to example.tld.</p>"},{"location":"modules/nixos/ntfy-sh/#client","title":"Client","text":""},{"location":"modules/nixos/ntfy-sh/#android","title":"Android","text":"<ol> <li>Download and install the ntfy app.</li> <li>Open the ntfy app.</li> <li>Allow notifications for ntfy.</li> <li>Subscribe to your topics:<ol> <li>Click on the plus icon in the bottom right corner.</li> <li>Enter your topic (e.g. foo-bar, see server setup above).</li> <li>Check Use another server.</li> <li>Enter your ntfy url (<code>services.ntfy-sh.settings.base-url</code>).</li> <li>Click Subscribe.</li> </ol> </li> </ol>"},{"location":"modules/nixos/nvidia/","title":"Nvidia","text":"<p>NixOS module that configures your Nvidia GPU with proprietary drivers.</p> <p>Tested on Turing and Ampere. Should work with most modern Nvidia GPUs.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/nvidia/#setup","title":"Setup","text":"<p>Import this module inside your NixOS configuration:</p> <pre><code>imports = [ inputs.core.nixosModules.nvidia ];\n</code></pre>"},{"location":"modules/nixos/nvidia/#config","title":"Config","text":"<p>Set the Nvidia package with <code>hardware.nvidia.package</code>. The default ist:</p> <pre><code>imports = [ inputs.core.nixosModules.nvidia ];\n\nhardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.latest;\n</code></pre>"},{"location":"modules/nixos/open-webui-oci/","title":"Open WebUI OCI","text":"<p>Open WebUI is an extensible, self-hosted AI interface that adapts to your workflow, all while operating entirely offline.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/open-webui-oci/#references","title":"References","text":"<ul> <li>Homepage</li> <li>GitHub</li> <li>Environment Configuration</li> </ul>"},{"location":"modules/nixos/open-webui-oci/#configuration","title":"Configuration","text":"<pre><code>{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.open-webui-oci ];\n\n  services.open-webui-oci.enable = true;\n}\n</code></pre>"},{"location":"modules/nixos/open-webui-oci/#usage","title":"Usage","text":"<p>Visit the web interface at your specified location to create an admin account.</p> <p>The default location is <code>http://127.0.0.1:8080</code>.</p>"},{"location":"modules/nixos/open-webui-oci/#troubleshooting","title":"Troubleshooting","text":""},{"location":"modules/nixos/open-webui-oci/#json-parse-error","title":"JSON parse error","text":"<p>If you get this error in the web interface:</p> <pre><code>SyntaxError: Unexpected token 'd', \"data: {\"id\"... is not valid JSON category\n</code></pre> <p>Clear your browser cache. Steps on Chromium based browsers:</p> <ol> <li>Open DevTools (F12) \u2192 Right-click refresh button</li> <li>Click \"Empty Cache and Hard Reload\"</li> </ol>"},{"location":"modules/nixos/peertube/","title":"Peertube","text":"<p>PeerTube is a free and open-source, decentralized, ActivityPub federated video platform.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/peertube/#references","title":"References","text":"<p>docs</p>"},{"location":"modules/nixos/peertube/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secret(s)</p> <pre><code>peertube:\n    secret: abc123\n</code></pre>"},{"location":"modules/nixos/peertube/#setup","title":"Setup","text":"<p>Initially, rebuild with:</p> <pre><code>services.peertube = {\n  enable = true;\n  settings.signup = {\n    enabled = true;\n    requires_approval = false;\n  };\n};\n</code></pre> <p>Then, create an account in the web interface. After that, rebuild with signups disabled.</p>"},{"location":"modules/nixos/print-server/","title":"Print server","text":"<p>Note: This module is not actively maintained. Expect things to break!</p> <p>This module sets up a printing server with a web interface.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/radicale/","title":"Radicale","text":"<p>A simple CalDAV and CardDAV server.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/radicale/#references","title":"References","text":"<ul> <li>Documentation</li> <li>Wiki</li> <li>GitHub</li> </ul>"},{"location":"modules/nixos/radicale/#sops","title":"Sops","text":"<p>Provide every user's SHA512 hashed password to your host's <code>secrets.yaml</code>:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>radicale:\n    user1: abc123\n    user2: abc123\n    # ...\n</code></pre> <p>Generate hashed passwords with:</p> <pre><code>nix-shell -p openssl --run 'openssl passwd -6 &lt;password&gt;'\n</code></pre>"},{"location":"modules/nixos/radicale/#setup","title":"Setup","text":"<p>Set a CNAME record for your Radicale subdomain (<code>dav</code> by default) pointing to your domain.</p>"},{"location":"modules/nixos/radicale/#config","title":"Config","text":"<pre><code>{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.radicale ];\n\n  services.radicale = {\n    enable = true;\n    users = [\n      \"user1\"\n      \"user2\"\n    ];\n  };\n}\n</code></pre>"},{"location":"modules/nixos/rss-bridge/","title":"RSS-Bridge","text":"<p>RSS-Bridge is a PHP web application. It generates web feeds for websites that don't have one.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/rss-bridge/#references","title":"References","text":"<ul> <li>docs</li> <li>repo</li> <li>bridges</li> </ul>"},{"location":"modules/nixos/searx/","title":"Searx","text":"<p>Searx is a free and open-source metasearch engine.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/searx/#references","title":"References","text":"<ul> <li>docs</li> <li>settings.yml</li> </ul>"},{"location":"modules/nixos/searx/#sops","title":"Sops","text":"<p>Provide the following entries to your secrets.yaml:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>searx:\n    secret-key: abc123\n</code></pre>"},{"location":"modules/nixos/sops/","title":"Sops","text":"<p>Atomic secret provisioning for NixOS based on sops.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/sops/#references","title":"References","text":"<ul> <li>GitHub</li> </ul>"},{"location":"modules/nixos/sops/#setup","title":"Setup","text":"<p>Generate an age key for your host from its ssh host key:</p> <pre><code>nix-shell -p ssh-to-age --run 'cat /etc/ssh/ssh_host_ed25519_key.pub | ssh-to-age'\n</code></pre> <p>Then, add it to <code>.sops.yaml</code> (see usage example).</p>"},{"location":"modules/nixos/sops/#config","title":"Config","text":""},{"location":"modules/nixos/sops/#flake","title":"Flake","text":"<pre><code># flake.nix\ninputs = {\n  sops-nix.url = \"github:Mic92/sops-nix\";\n  sops-nix.inputs.nixpkgs.follows = \"nixpkgs\";\n};\n</code></pre>"},{"location":"modules/nixos/sops/#host-configuration","title":"Host configuration","text":"<p>Create a <code>secrets</code> directory in your hosts directory. Declare all your secrets in it:</p> <pre><code># hosts/YOUR_HOST/secrets/default.nix\n{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.sops ];\n\n  sops.secrets.your-secret = { };\n  sops.secrets.other-secret = { };\n</code></pre>"},{"location":"modules/nixos/sops/#usage","title":"Usage","text":"<p>For more information on how to use sops-nix, see the Sops Home Manager module documentation.</p>"},{"location":"modules/nixos/sops/#update-keys","title":"Update Keys","text":"<p>Update the keys of your SOPS files after making changes to <code>.sops.yaml</code>:</p> <pre><code>sops --config PATH/TO/.sops.yaml updatekeys PATH/TO/secrets.yaml\n</code></pre>"},{"location":"modules/nixos/tailscale/","title":"Tailscale","text":"<p>Private WireGuard networks made easy.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/tailscale/#references","title":"References","text":"<ul> <li>Website</li> <li>GitHub</li> <li>Documents</li> </ul>"},{"location":"modules/nixos/tailscale/#sops","title":"Sops","text":"<p>Provide the following entries to your <code>secrets.yaml</code>:</p> <p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>tailscale:\n    auth-key: abc123\n</code></pre>"},{"location":"modules/nixos/tailscale/#config","title":"Config","text":"<pre><code>{\n  imports = [ inputs.core.nixosModules.tailscale ];\n\n  services.tailscale = {\n    enable = true;\n    enableSSH = true;\n    loginServer = \"&lt;your-headscale-instance&gt;\";\n  };\n}\n</code></pre>"},{"location":"modules/nixos/uptime-kuma-agent/","title":"Uptime Kuma Agent","text":"<p>Monitor systemd services via Uptime Kuma's push URLs.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/uptime-kuma-agent/#setup","title":"Setup","text":"<p>You need a running Uptime Kuma instance to push status updates to. See the Uptime Kuma NixOS module.</p> <p>Add a new monitor. Set:</p> <ul> <li>Monitor Type: Push</li> </ul> <p>Copy the Push URL without its params, e.g.: <code>https://kuma.domain.tld/api/push/3LsNQqO4V8</code></p> <p>Put this URL into the monitor's <code>secretFile</code> (see below).</p>"},{"location":"modules/nixos/uptime-kuma-agent/#config","title":"Config","text":"<pre><code>{\n  imports = [ inputs.core.nixosModules.uptime-kuma-agent ];\n\n  services.uptime-kuma-agent = {\n    enable = true;\n    monitors = {\n      example = {\n        secretFile = config.sops.secrets.\"uptime-kuma-agent/example\".path;\n      };\n    };\n  };\n\n  sops.secrets.\"uptime-kuma-agent/example\".path = { };\n}\n</code></pre>"},{"location":"modules/nixos/vaultwarden/","title":"Vaultwarden","text":"<p>Unofficial Bitwarden compatible server written in Rust, formerly known as bitwarden_rs.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/vaultwarden/#references","title":"References","text":"<ul> <li>repo</li> <li>docs</li> </ul>"},{"location":"modules/nixos/vaultwarden/#sops","title":"Sops","text":"<p>Replace <code>abc123</code> with your actual secrets</p> <pre><code>vaultwarden:\n    admin-token: abc123\n    smtp-password: abc123 # for email support (local or external mailserver)\n    hashed-smtp-password: abc123 # for email support (local mailserver only)\n</code></pre> <p>Generate the hashed smtp password with:</p> <pre><code>nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'\n</code></pre> <p>For more info, see our mailserver module.</p> <p>Optionally, you can store your admin token as an argon2 PHC string with the OWASP minimum recommended settings in sops. It is recommended to use an alphanumeric string only, as special characters may need to be escaped:</p> <pre><code>nix-shell -p openssl libargon2 --run 'echo -n \"abc123\" | argon2 \"$(openssl rand -base64 32)\" -e -id -k 19456 -t 2 -p 1'\n</code></pre>"},{"location":"modules/nixos/vaultwarden/#setup","title":"Setup","text":"<ul> <li>Visit <code>https://SUBDOMAIN.DOMAIN.TLD/admin</code> and enter the admin token.</li> <li>Click on \"Users\" in the top row.</li> <li>Invite users via email in the box at the bottom.</li> </ul>"},{"location":"modules/nixos/virtualisation/","title":"Virtualisation","text":"<p>Virtualisation using QEMU via libvirt and managed through Virt-manager with VFIO support.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/virtualisation/#overview","title":"Overview","text":"<ol> <li>QEMU is the hypervisor that provides the core virtualisation capabilities.</li> <li>libvirt is a toolkit and API that manages virtualisation platforms, such as QEMU.</li> <li>Virt-manager is a GUI tool that interacts with libvirt to manage VMs.</li> <li>virsh is a CLI tool that interacts with libvirt to manage VMs.</li> </ol>"},{"location":"modules/nixos/virtualisation/#docs","title":"Docs","text":""},{"location":"modules/nixos/virtualisation/#qemu","title":"QEMU","text":"<ul> <li>Official docs</li> </ul>"},{"location":"modules/nixos/virtualisation/#libvirt","title":"libvirt","text":"<ul> <li>Official docs</li> <li>Arch Wiki</li> <li>virsh CLI</li> </ul> <p>If you are using the Home Manager module as well, then <code>virsh</code> is aliased to <code>virsh --connect qemu:///system</code></p>"},{"location":"modules/nixos/virtualisation/#virt-manager","title":"Virt-manager","text":"<ul> <li>GitHub Repository</li> <li>NixOS Official Wiki</li> <li>NixOS Community Wiki</li> <li>Arch Wiki</li> </ul>"},{"location":"modules/nixos/virtualisation/#setup","title":"Setup","text":"<ol> <li>Import this module in your NixOS config. It is recommended to use the Virtualisation Manager module as well.</li> <li>Add your user to the <code>libvirtd</code>, <code>qemu-libvirtd</code> and <code>kvm</code> group:     <pre><code>users.extraGroups.libvirtd.members = [ \"&lt;you&gt;\" ];\nusers.extraGroups.qemu-libvirtd.members = [ \"&lt;you&gt;\" ];\nusers.extraGroups.kvm.members = [ \"&lt;you&gt;\" ];\n</code></pre></li> <li>Rebuild and reboot: <code>rebuild all &amp;&amp; sudo reboot now</code></li> <li>Enable and start the default network and reboot again: <code>virsh net-autostart default &amp;&amp; virsh net-start default</code></li> </ol>"},{"location":"modules/nixos/virtualisation/#vfio","title":"VFIO","text":""},{"location":"modules/nixos/virtualisation/#setup_1","title":"Setup","text":"<p>For successful PCI device passthrough, devices must be properly isolated by IOMMU groups. A device can be safely passed through if: - It is the only device in its IOMMU group (recommended), OR - All devices in its IOMMU group are passed through together</p> <p>This module includes an <code>iommu-groups</code> command to help identify IOMMU groups:</p> <pre><code>iommu-groups\n</code></pre> <p>In this example, IOMMU group 9 contains only the Nvidia GPU which will get passed to the VM:</p> <pre><code>IOMMU Group 9 01:00.0 3D controller [0302]: NVIDIA Corporation TU117M [GeForce GTX 1650 Mobile / Max-Q] [10de:1f9d] (rev a1)\n</code></pre> <p>Take not of the PCI device ID. In this case: <code>10de:1f9d</code>.</p>"},{"location":"modules/nixos/virtualisation/#config","title":"Config","text":"<p>This is an example with the Nvidia GPU above:</p> <pre><code>{ inputs, ... }:\n\n{\n  imports = [ inputs.core.nixosModules.virtualisation ];\n\n  virtualisation = {\n    vfio = {\n      enable = true;\n      IOMMUType = \"amd\";\n      devices = [\n        \"10de:1f9d\"\n      ];\n      blacklistNvidia = true;\n    };\n    hugepages.enable = true;\n  };\n}\n</code></pre>"},{"location":"modules/nixos/virtualisation/#virt-manager_1","title":"Virt Manager","text":""},{"location":"modules/nixos/virtualisation/#1-open-vm-hardware-settings","title":"1. Open VM Hardware Settings","text":"<ul> <li>Select your VM in Virt Manager</li> <li>Click \"Show virtual hardware details\"</li> </ul>"},{"location":"modules/nixos/virtualisation/#2-add-pci-host-device","title":"2. Add PCI Host Device","text":"<ul> <li>Click \"Add Hardware\" button at bottom</li> <li>Select \"PCI Host Device\" from the list</li> <li>Click \"Finish\"</li> </ul> <p>You may repeat this process for as many devices as you want to add to your VM.</p>"},{"location":"modules/nixos/virtualisation/#looking-glass-with-kvmfr","title":"Looking Glass with KVMFR","text":"<p>This has not yet been tested.</p>"},{"location":"modules/nixos/virtualisation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"modules/nixos/virtualisation/#check-kernel-parameters","title":"Check Kernel Parameters","text":"<p>View current kernel parameters:</p> <pre><code>cat /proc/cmdline\n</code></pre> <p>Check VFIO-related parameters:</p> <pre><code>dmesg | grep -i vfio\n</code></pre> <p>Verify IOMMU is enabled:</p> <pre><code>dmesg | grep -i iommu\n</code></pre>"},{"location":"modules/nixos/virtualisation/#verify-device-binding","title":"Verify device binding","text":"<pre><code>lscpi -k\n</code></pre> <p>Look for your device you want to pass through. It should say:</p> <pre><code>Kernel driver in use: vfio-pci\n</code></pre> <p>For example:</p> <pre><code>01:00.0 3D controller: NVIDIA Corporation TU117M [GeForce GTX 1650 Mobile / Max-Q] (rev a1)\n    Subsystem: Lenovo Device 380d\n    Kernel driver in use: vfio-pci\n    Kernel modules: nvidiafb, nouveau\n</code></pre>"},{"location":"modules/nixos/virtualisation/#verify-module-status","title":"Verify module status","text":"<p>Ensure blacklisted modules are not loaded:</p> <pre><code>lsmod | grep nvidia\nlsmod | grep nouveau\n</code></pre> <p>These should return nothing.</p>"},{"location":"modules/nixos/virtualisation/#vfio-pciids-not-appearing","title":"<code>vfio-pci.ids</code> not appearing","text":"<p>Check generated bootloader config:</p> <pre><code>cat /boot/loader/entries/nixos-*.conf\n</code></pre>"},{"location":"modules/nixos/webpage/","title":"Web Page","text":"<p>A very simple module to serve a static web page behind a reverse proxy using nginx.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/windows-oci/","title":"Windows OCI","text":"<p>Windows inside a Docker container.</p> <p>View the nix-core NixOS module on GitHub.</p>"},{"location":"modules/nixos/windows-oci/#references","title":"References","text":"<ul> <li>dockur on GitHub</li> </ul>"},{"location":"modules/nixos/windows-oci/#config","title":"Config","text":"<pre><code>imports = [ inputs.core.nixosModule.windows-oci ];\n\nservices.windows-oci.enable = true;\n</code></pre>"},{"location":"modules/nixos/windows-oci/#setup","title":"Setup","text":"<p>You can monitor the installation process with:</p> <pre><code>journalctl -u podman-windows.service -f\n</code></pre> <p>The first-time setup may fail. Rebooting should resolve the issue.</p>"},{"location":"modules/nixos/windows-oci/#usage","title":"Usage","text":"<p>Access the VNC web interface at <code>http://127.0.0.1:8006</code>. Or connect via RDP at <code>127.0.0.1</code>.</p> <p>TODO: Setup Windows RemoteApp</p>"},{"location":"tips/dependency-tracing/","title":"Dependency Tracing","text":"<p>Dependency tracing in Nix allows you to understand the relationships between packages in your system configuration.</p>"},{"location":"tips/dependency-tracing/#forward-path-tracing","title":"Forward Path Tracing","text":"<p>This section answers the question: \"What are the dependencies of an installed package?\"</p> <p>Print a store path's dependency tree with:</p> <pre><code>nix-store --query --tree /nix/store/...\n</code></pre> <p>Get a package's store path with:</p> <p>Replace <code>YOUR_CONFIG</code> with the name of your NixOS or Home Manager configuration, and <code>PACKAGE</code> with the name of the package you want to analyze.</p>"},{"location":"tips/dependency-tracing/#nixos","title":"NixOS","text":"<pre><code>nix path-info ~/.config/nixos#nixosConfigurations.YOUR_CONFIG.pkgs.PACKAGE\n</code></pre>"},{"location":"tips/dependency-tracing/#home-manager","title":"Home Manager","text":"<pre><code>nix path-info ~/.config/nixos#homeConfigurations.YOUR_CONFIG.pkgs.PACKAGE\n</code></pre>"},{"location":"tips/dependency-tracing/#backward-path-tracing","title":"Backward Path Tracing","text":"<p>This section answers the question: \"What are parents of an installed package?\" or \"Why is a certain package installed?\"</p> <p>Print a package's dependency path with:</p> <p>Replace <code>YOUR_CONFIG</code> with the name of your NixOS or Home Manager configuration, and <code>PACKAGE</code> with the name of the package you want to analyze.</p>"},{"location":"tips/dependency-tracing/#nixos_1","title":"NixOS","text":"<pre><code>nix why-depends --derivation ~/.config/nixos#nixosConfigurations.YOUR_CONFIG.config.system.build.toplevel ~/.config/nixos#nixosConfigurations.YOUR_CONFIG.pkgs.PACKAGE\n</code></pre>"},{"location":"tips/dependency-tracing/#home-manager_1","title":"Home Manager","text":"<pre><code>nix why-depends --derivation ~/.config/nixos#homeConfigurations.YOUR_CONFIG.activationPackage ~/.config/nixos#homeConfigurations.YOUR_CONFIG.pkgs.PACKAGE\n</code></pre>"},{"location":"tips/useful-links/","title":"Useful Links","text":"<p>A collection of links regarding Nix/NixOS.</p>"},{"location":"tips/useful-links/#documentation","title":"Documentation","text":"<ul> <li>Nix Pills: An introduction to Nix, ported to the current format.</li> <li>NixOS &amp; Flakes Book: An unofficial book for beginners.</li> <li>Noogle: Search Nix functions.</li> <li>nix-lib: Nix (builtins) &amp; Nixpkgs (lib) functions.</li> <li>nix.dev: Official documentation for the Nix ecosystem.</li> </ul>"},{"location":"tips/useful-links/#tools","title":"Tools","text":"<ul> <li>N\u00fcschtOS search: Simple and fast static-page NixOS option search.</li> <li>compose2nix: Generate a NixOS config from a Docker Compose project. </li> <li>manix: A fast CLI documentation searcher for Nix. </li> <li>nix-tree: Interactively browse dependency graphs of Nix derivations. </li> <li>tex2nix: Generate texlive nix expressions for documents.</li> </ul>"},{"location":"tips/useful-links/#nixos-configurations","title":"NixOS configurations","text":"<ul> <li>srvos: NixOS profiles for servers.</li> </ul>"}]}